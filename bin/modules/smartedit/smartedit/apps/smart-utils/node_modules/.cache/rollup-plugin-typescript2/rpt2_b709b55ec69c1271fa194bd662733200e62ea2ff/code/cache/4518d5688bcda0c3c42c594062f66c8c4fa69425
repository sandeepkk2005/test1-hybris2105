{"code":"/*\r\n * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.\r\n */\r\n/**\r\n * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.\r\n * @module smartutils\r\n */\r\nimport * as lodash from 'lodash';\r\nimport { FunctionsUtils } from '../utils';\r\n/** @internal */\r\nvar annotationType;\r\n(function (annotationType) {\r\n    // eslint-disable-next-line @typescript-eslint/no-shadow\r\n    annotationType[\"Class\"] = \"ClassAnnotation\";\r\n    annotationType[\"Method\"] = \"MethodAnnotation\";\r\n})(annotationType || (annotationType = {}));\r\n/**\r\n * @ngdoc service\r\n * @name @smartutils.services:AnnotationService\r\n *\r\n * @description\r\n * Utility service to declare and consume method level and class level {@link https://www.typescriptlang.org/docs/handbook/decorators.html Typescript decorator factories}.\r\n * <br/>Since Decorator is a reserved word in Smartedit, Typescript Decorators are called as Annotations.\r\n */\r\nvar AnnotationService = /** @class */ (function () {\r\n    function AnnotationService() {\r\n        this.INJECTABLE_NAME_KEY = 'getInjectableName';\r\n        this.ORIGINAL_CONSTRUCTOR_KEY = 'originalConstructor';\r\n        /**\r\n         * @ngdoc method\r\n         * @name @smartutils.services:AnnotationService#getClassAnnotations\r\n         * @methodOf @smartutils.services:AnnotationService\r\n         *\r\n         * @description\r\n         * Retrieves an object with all the string-indexed annotations defined on the given class target\r\n         * @param {any} target The typescript class on which class annotations are defined\r\n         * @returns {[index: string]: any} an object contains string-indexed annotation name and payload\r\n         */\r\n        this.getClassAnnotations = lodash.memoize(this.getClassAnnotationsLogic);\r\n        /**\r\n         * @ngdoc method\r\n         * @name @smartutils.services:AnnotationService#getMethodAnnotations\r\n         * @methodOf @smartutils.services:AnnotationService\r\n         *\r\n         * @description\r\n         * Retrieves an object with all the string indexed annotations defined on the given class method\r\n         * @param {any} target The typescript class to the inspected\r\n         * @param {string} propertyName The name of the method on which annotations are defined\r\n         * @returns {[index: string]: any} an object contains string-indexed annotation name and payload\r\n         */\r\n        this.getMethodAnnotations = lodash.memoize(this.getMethodAnnotationsLogic, function (target, propertyName) {\r\n            return JSON.stringify(target.prototype) + propertyName;\r\n        });\r\n        this.functionsUtils = new FunctionsUtils();\r\n        this.annotationFactoryMap = {};\r\n    }\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#getClassAnnotation\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Retrieves arguments of class annotation under a given annotation name\r\n     * @param {any} target The typescript class on which class annotation is defined\r\n     * @param {(args?: any) => ClassDecorator} annotation The type of the class annotation\r\n     * @returns {any} the payload passed to the annotation\r\n     */\r\n    AnnotationService.prototype.getClassAnnotation = function (target, annotation) {\r\n        var annotationMap = this.getClassAnnotations(target);\r\n        var annotationName = annotation.annotationName;\r\n        if (annotationMap) {\r\n            if (annotationName in annotationMap) {\r\n                return annotationMap[annotationName];\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#getMethodAnnotation\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Retrieves arguments of method annotation for a given typescript class\r\n     * @param {any} target The typescript class\r\n     * @param {string} propertyName The name of the method on which annotation is defined\r\n     * @param {(args?: any) => MethodDecorator)} annotation The type of the method annotation\r\n     * @returns {any} the payload passed to the annotation\r\n     */\r\n    AnnotationService.prototype.getMethodAnnotation = function (target, propertyName, annotation) {\r\n        var annotationMap = this.getMethodAnnotations(target, propertyName);\r\n        var annotationName = annotation.annotationName;\r\n        if (annotationMap) {\r\n            if (annotationName in annotationMap) {\r\n                return annotationMap[annotationName];\r\n            }\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#hasClassAnnotation\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Determines whether a given class target has given annotation name defined or not\r\n     * @param {any} target The typescript class on which class annotation is defined\r\n     * @param {(args?: any) => ClassDecorator} annotation The type of the class annotation\r\n     * @returns {boolean} true if a given target has given annotation name. Otherwise false.\r\n     */\r\n    AnnotationService.prototype.hasClassAnnotation = function (target, annotation) {\r\n        var annotationMap = this.getClassAnnotations(target);\r\n        return annotation.annotationName in annotationMap ? true : false;\r\n    };\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#hasMethodAnnotation\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Determines whether a given method name has given annotation name defined or not under a given typescript class\r\n     * @param {any} target The typescript class object\r\n     * @param {string} propertyName The name of the method on which annotation is defined\r\n     * @param {(args?: any) => MethodDecorator} annotation The type of the method annotation\r\n     * @returns {boolean} true if a given method name has given annotation name. Otherwise false.\r\n     */\r\n    AnnotationService.prototype.hasMethodAnnotation = function (target, propertyName, annotation) {\r\n        var annotationMap = this.getMethodAnnotations(target, propertyName);\r\n        return annotation.annotationName in annotationMap ? true : false;\r\n    };\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#setClassAnnotationFactory\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Registers a {@link @smartutils.object:ClassAnnotationFactory ClassAnnotationFactory} under a given name.\r\n     * <br/>Typically, in order for the ClassAnnotationFactory to benefit from Angular dependency injection, this method will be called within an Angular factory.\r\n     * @param {string} name the name of the factory.\r\n     * @returns {ClassAnnotationFactory} a {@link @smartutils.object:ClassAnnotationFactory ClassAnnotationFactory}\r\n     */\r\n    AnnotationService.prototype.setClassAnnotationFactory = function (name, annotationFactory) {\r\n        this.annotationFactoryMap[name] = annotationFactory;\r\n        return annotationFactory;\r\n    };\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#getClassAnnotationFactory\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Retrieves a {@link @smartutils.object:ClassAnnotationFactory ClassAnnotationFactory}\r\n     * previously registered under the given name:\r\n     *\r\n     * <pre>\r\n     *   export const GatewayProxied = annotationService.getClassAnnotationFactory('GatewayProxied');\r\n     * </pre>\r\n     *\r\n     * @param {string} name The name of the factory\r\n     * @returns {ClassAnnotationFactory} a {@link @smartutils.object:ClassAnnotationFactory ClassAnnotationFactory}\r\n     */\r\n    AnnotationService.prototype.getClassAnnotationFactory = function (name) {\r\n        var instance = this;\r\n        var classAnnotationFactory = function () {\r\n            var factoryArgument = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                factoryArgument[_i] = arguments[_i];\r\n            }\r\n            return function (originalConstructor) {\r\n                var newConstructor = instance.functionsUtils.extendsConstructor(originalConstructor, function () {\r\n                    var args = [];\r\n                    for (var _i = 0; _i < arguments.length; _i++) {\r\n                        args[_i] = arguments[_i];\r\n                    }\r\n                    var annotationFactory = instance.annotationFactoryMap[name];\r\n                    if (annotationFactory) {\r\n                        // Note: Before we used to bind originalConstructor.bind(this). However, it had to be left up to the caller\r\n                        // since that causes problems in IE; when a function is bound in IE, the browser wraps it in a function with\r\n                        // native code, making it impossible to retrieve its name.\r\n                        var result = annotationFactory(factoryArgument)(this, originalConstructor, args);\r\n                        if (result) {\r\n                            return result;\r\n                        }\r\n                    }\r\n                    else {\r\n                        throw new Error(\"annotation '\" + name + \"' is used on '\" + originalConstructor.name + \"' but its ClassAnnotationFactory may not have been added to the dependency injection\");\r\n                    }\r\n                });\r\n                /*\r\n                 * enable Angular and AngularJS to inject this new constructor even though it has an empty signature\r\n                 * by copying $inject property and DI related Angular metatdata\r\n                 * For idempotency purposes we copy all properties anyways\r\n                 */\r\n                lodash.merge(newConstructor, originalConstructor);\r\n                /*\r\n                 * some properties set by Angular are not enumerable and yet contain\r\n                 * such information as @Inject \"metadata\" necessary for DI\r\n                 */\r\n                newConstructor.__annotations__ = originalConstructor.__annotations__;\r\n                newConstructor.__parameters__ = originalConstructor.__parameters__;\r\n                newConstructor.__prop__metadata__ = originalConstructor.__prop__metadata__;\r\n                /*\r\n                 * copying such metadata as design:paramtypes necessary for DI\r\n                 */\r\n                Reflect.getMetadataKeys(originalConstructor).forEach(function (key) {\r\n                    Reflect.defineMetadata(key, Reflect.getMetadata(key, originalConstructor), newConstructor);\r\n                });\r\n                var rootOriginalConstructor = instance.getOriginalConstructor(originalConstructor);\r\n                Reflect.defineMetadata(instance.ORIGINAL_CONSTRUCTOR_KEY, rootOriginalConstructor, newConstructor);\r\n                Reflect.defineMetadata(annotationType.Class + ':' + name, factoryArgument, rootOriginalConstructor);\r\n                // override original constructor\r\n                return newConstructor;\r\n            };\r\n        };\r\n        classAnnotationFactory.annotationName = name;\r\n        return classAnnotationFactory;\r\n    };\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#setMethodAnnotationFactory\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Registers a {@link @smartutils.object:MethodAnnotationFactory MethodAnnotationFactory} under a given name.\r\n     * <br/>Typically, in order for the MethodAnnotationFactory to benefit from Angular dependency injection, this method will be called within an Angular factory.\r\n     * @param {string} name The name of the factory.\r\n     * @returns {MethodAnnotationFactory} a {@link @smartutils.object:MethodAnnotationFactory MethodAnnotationFactory}\r\n     */\r\n    AnnotationService.prototype.setMethodAnnotationFactory = function (name, annotationFactory) {\r\n        this.annotationFactoryMap[name] = annotationFactory;\r\n        return annotationFactory;\r\n    };\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#getMethodAnnotationFactory\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Retrieves a method level {@link @smartutils.object:MethodAnnotationFactory MethodAnnotationFactory}\r\n     * previously registered under the given name:\r\n     *\r\n     * <pre>\r\n     *   export const Cached = annotationService.getMethodAnnotationFactory('Cached');\r\n     * </pre>\r\n     *\r\n     * @param {string} name the name of the factory.\r\n     * @returns {MethodAnnotationFactory} a {@link @smartutils.object:MethodAnnotationFactory MethodAnnotationFactory}.\r\n     */\r\n    AnnotationService.prototype.getMethodAnnotationFactory = function (name) {\r\n        var instance = this;\r\n        var methodAnnotationFactory = function () {\r\n            var factoryArgument = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                factoryArgument[_i] = arguments[_i];\r\n            }\r\n            /*\r\n             * when decorating an abstract class, strangely enough target is an instance of the abstract class\r\n             * we need pass \"this\" instead to the annotationFactory invocation\r\n             */\r\n            return function (target, propertyName, descriptor) {\r\n                var originalMethod = descriptor.value;\r\n                descriptor.value = function () {\r\n                    var annotationFactory = instance\r\n                        .annotationFactoryMap[name];\r\n                    if (annotationFactory) {\r\n                        return originalMethod\r\n                            ? annotationFactory(factoryArgument)(this, propertyName, originalMethod.bind(this), arguments)\r\n                            : undefined;\r\n                    }\r\n                    else {\r\n                        throw new Error(\"annotation '\" + name + \"' is used but its MethodAnnotationFactory may not have been added to the dependency injection\");\r\n                    }\r\n                };\r\n                Reflect.defineMetadata(annotationType.Method + ':' + name, factoryArgument, target, propertyName);\r\n            };\r\n        };\r\n        methodAnnotationFactory.annotationName = name;\r\n        return methodAnnotationFactory;\r\n    };\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#getOriginalConstructor\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Given a class constructor, returns the original constructor of it prior to any class level\r\n     * proxying by annotations declared through {@link @smartutils.services:AnnotationService AnnotationService}\r\n     *\r\n     * @param {Class} target the constructor\r\n     */\r\n    AnnotationService.prototype.getOriginalConstructor = function (target) {\r\n        return Reflect.getMetadata(this.ORIGINAL_CONSTRUCTOR_KEY, target) || target;\r\n    };\r\n    AnnotationService.prototype.getClassAnnotationsLogic = function (target) {\r\n        var originalConstructor = this.getOriginalConstructor(target);\r\n        var annotationMap = {};\r\n        Reflect.getMetadataKeys(originalConstructor)\r\n            .filter(function (key) { return key.toString().startsWith(annotationType.Class); })\r\n            .map(function (key) {\r\n            annotationMap[key.split(':')[1]] = Reflect.getMetadata(key, originalConstructor);\r\n        });\r\n        return annotationMap;\r\n    };\r\n    AnnotationService.prototype.getMethodAnnotationsLogic = function (target, propertyName) {\r\n        var annotationMap = {};\r\n        Reflect.getMetadataKeys(target.prototype, propertyName)\r\n            .filter(function (key) { return key.toString().startsWith(annotationType.Method); })\r\n            .map(function (key) {\r\n            annotationMap[key.split(':')[1]] = Reflect.getMetadata(key, target.prototype, propertyName);\r\n        });\r\n        return annotationMap;\r\n    };\r\n    return AnnotationService;\r\n}());\r\nexport { AnnotationService };\r\nexport var annotationService = new AnnotationService();\r\n//# sourceMappingURL=annotation.service.js.map","references":["/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedittools/common/temp/node_modules/.pnpm/@types/lodash@4.14.159/node_modules/@types/lodash/ts3.1/index.d.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/src/dtos/index.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/src/types/index.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/src/utils/index.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedittools/common/temp/node_modules/.pnpm/reflect-metadata@0.1.13/node_modules/reflect-metadata/index.d.ts"],"map":"{\"version\":3,\"file\":\"annotation.service.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/services/annotation.service.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/services/annotation.service.d.ts","writeByteOrderMark":false,"text":"/**\r\n * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.\r\n * @module smartutils\r\n */\r\nimport * as lodash from 'lodash';\r\nimport { TypedMap } from '../dtos';\r\nimport { Class } from '../types';\r\n/**\r\n * @ngdoc object\r\n * @name @smartutils.object:MethodAnnotation\r\n *\r\n * @description\r\n * Shorthand signature of a {@link https://www.typescriptlang.org/docs/handbook/decorators.html Typescript Decorator} function for methods\r\n * used by {@link @smartutils.services:AnnotationService AnnotationService}.\r\n * @param {any} target the instance the method of which is annotated\r\n * @param {any} propertyName the name of the method that is annotated\r\n * @param {any} originalMethod the original method being annotated, it is prebound to the instance\r\n * @returns {any} the final return value of the proxied method.\r\n * It is left to implementers to discard, modify, reuse the original method.\r\n */\r\nexport declare type MethodAnnotation = (target: any, propertyName: string, originalMethod: (...x: any[]) => any, ...invocationArguments: any[]) => any;\r\n/**\r\n * @ngdoc object\r\n * @name @smartutils.object:MethodAnnotationFactory\r\n *\r\n * @description\r\n * A {@link @smartutils.object:MethodAnnotation MethodAnnotation} factory\r\n * used by {@link @smartutils.services:AnnotationService AnnotationService}.\r\n * @param {...any[]} factoryArguments the factory arguments\r\n * @returns {MethodAnnotation} {@link @smartutils.object:MethodAnnotation MethodAnnotation}\r\n */\r\nexport declare type MethodAnnotationFactory = (...factoryArguments: any[]) => MethodAnnotation;\r\n/**\r\n * @ngdoc object\r\n * @name @smartutils.object:ClassAnnotation\r\n *\r\n * @description\r\n * Shorthand signature of a {@link https://www.typescriptlang.org/docs/handbook/decorators.html Typescript Decorator} function for classes\r\n * used by {@link @smartutils.services:AnnotationService AnnotationService}.\r\n * @param {any} instance an instance of the class which is annotated\r\n * @param {(...x: any[]) => any} originalConstructor the prebound original constructor of the instance\r\n * @param {...any[]} invocationArguments the arguments with which the constructor is invoked\r\n * @returns {any} void or a new instance.\r\n * It is left to implementers to discard, modify, or reuse the original constructor then not to return or return a new instance.\r\n */\r\nexport declare type ClassAnnotation = (instance: any, originalConstructor: (...x: any[]) => any, ...invocationArguments: any[]) => any;\r\n/**\r\n * @ngdoc object\r\n * @name @smartutils.object:ClassAnnotationFactory\r\n *\r\n * @description\r\n * A {@link @smartutils.object:ClassAnnotation ClassAnnotation} factory\r\n * used by {@link @smartutils.services:AnnotationService AnnotationService}.\r\n * @param {...any[]} factoryArguments the factory arguments\r\n * @returns {ClassAnnotation} {@link @smartutils.object:ClassAnnotation ClassAnnotation}\r\n */\r\nexport declare type ClassAnnotationFactory = (...x: any[]) => ClassAnnotation;\r\n/**\r\n * @ngdoc service\r\n * @name @smartutils.services:AnnotationService\r\n *\r\n * @description\r\n * Utility service to declare and consume method level and class level {@link https://www.typescriptlang.org/docs/handbook/decorators.html Typescript decorator factories}.\r\n * <br/>Since Decorator is a reserved word in Smartedit, Typescript Decorators are called as Annotations.\r\n */\r\nexport declare class AnnotationService {\r\n    readonly INJECTABLE_NAME_KEY = \"getInjectableName\";\r\n    readonly ORIGINAL_CONSTRUCTOR_KEY = \"originalConstructor\";\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#getClassAnnotations\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Retrieves an object with all the string-indexed annotations defined on the given class target\r\n     * @param {any} target The typescript class on which class annotations are defined\r\n     * @returns {[index: string]: any} an object contains string-indexed annotation name and payload\r\n     */\r\n    getClassAnnotations: ((target: any) => TypedMap<any>) & lodash.MemoizedFunction;\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#getMethodAnnotations\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Retrieves an object with all the string indexed annotations defined on the given class method\r\n     * @param {any} target The typescript class to the inspected\r\n     * @param {string} propertyName The name of the method on which annotations are defined\r\n     * @returns {[index: string]: any} an object contains string-indexed annotation name and payload\r\n     */\r\n    getMethodAnnotations: ((target: any, propertyName: string) => TypedMap<any>) & lodash.MemoizedFunction;\r\n    private functionsUtils;\r\n    private annotationFactoryMap;\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#getClassAnnotation\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Retrieves arguments of class annotation under a given annotation name\r\n     * @param {any} target The typescript class on which class annotation is defined\r\n     * @param {(args?: any) => ClassDecorator} annotation The type of the class annotation\r\n     * @returns {any} the payload passed to the annotation\r\n     */\r\n    getClassAnnotation(target: any, annotation: (args?: any) => ClassDecorator): any;\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#getMethodAnnotation\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Retrieves arguments of method annotation for a given typescript class\r\n     * @param {any} target The typescript class\r\n     * @param {string} propertyName The name of the method on which annotation is defined\r\n     * @param {(args?: any) => MethodDecorator)} annotation The type of the method annotation\r\n     * @returns {any} the payload passed to the annotation\r\n     */\r\n    getMethodAnnotation(target: any, propertyName: string, annotation: (args?: any) => MethodDecorator): any;\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#hasClassAnnotation\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Determines whether a given class target has given annotation name defined or not\r\n     * @param {any} target The typescript class on which class annotation is defined\r\n     * @param {(args?: any) => ClassDecorator} annotation The type of the class annotation\r\n     * @returns {boolean} true if a given target has given annotation name. Otherwise false.\r\n     */\r\n    hasClassAnnotation(target: any, annotation: (args?: any) => ClassDecorator): boolean;\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#hasMethodAnnotation\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Determines whether a given method name has given annotation name defined or not under a given typescript class\r\n     * @param {any} target The typescript class object\r\n     * @param {string} propertyName The name of the method on which annotation is defined\r\n     * @param {(args?: any) => MethodDecorator} annotation The type of the method annotation\r\n     * @returns {boolean} true if a given method name has given annotation name. Otherwise false.\r\n     */\r\n    hasMethodAnnotation(target: any, propertyName: string, annotation: (args?: any) => MethodDecorator): boolean;\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#setClassAnnotationFactory\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Registers a {@link @smartutils.object:ClassAnnotationFactory ClassAnnotationFactory} under a given name.\r\n     * <br/>Typically, in order for the ClassAnnotationFactory to benefit from Angular dependency injection, this method will be called within an Angular factory.\r\n     * @param {string} name the name of the factory.\r\n     * @returns {ClassAnnotationFactory} a {@link @smartutils.object:ClassAnnotationFactory ClassAnnotationFactory}\r\n     */\r\n    setClassAnnotationFactory(name: string, annotationFactory: ClassAnnotationFactory | null): ClassAnnotationFactory | null;\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#getClassAnnotationFactory\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Retrieves a {@link @smartutils.object:ClassAnnotationFactory ClassAnnotationFactory}\r\n     * previously registered under the given name:\r\n     *\r\n     * <pre>\r\n     *   export const GatewayProxied = annotationService.getClassAnnotationFactory('GatewayProxied');\r\n     * </pre>\r\n     *\r\n     * @param {string} name The name of the factory\r\n     * @returns {ClassAnnotationFactory} a {@link @smartutils.object:ClassAnnotationFactory ClassAnnotationFactory}\r\n     */\r\n    getClassAnnotationFactory(name: string): (...args: any[]) => ClassDecorator;\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#setMethodAnnotationFactory\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Registers a {@link @smartutils.object:MethodAnnotationFactory MethodAnnotationFactory} under a given name.\r\n     * <br/>Typically, in order for the MethodAnnotationFactory to benefit from Angular dependency injection, this method will be called within an Angular factory.\r\n     * @param {string} name The name of the factory.\r\n     * @returns {MethodAnnotationFactory} a {@link @smartutils.object:MethodAnnotationFactory MethodAnnotationFactory}\r\n     */\r\n    setMethodAnnotationFactory(name: string, annotationFactory: MethodAnnotationFactory | null): MethodAnnotationFactory | null;\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#getMethodAnnotationFactory\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Retrieves a method level {@link @smartutils.object:MethodAnnotationFactory MethodAnnotationFactory}\r\n     * previously registered under the given name:\r\n     *\r\n     * <pre>\r\n     *   export const Cached = annotationService.getMethodAnnotationFactory('Cached');\r\n     * </pre>\r\n     *\r\n     * @param {string} name the name of the factory.\r\n     * @returns {MethodAnnotationFactory} a {@link @smartutils.object:MethodAnnotationFactory MethodAnnotationFactory}.\r\n     */\r\n    getMethodAnnotationFactory(name: string): any;\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:AnnotationService#getOriginalConstructor\r\n     * @methodOf @smartutils.services:AnnotationService\r\n     *\r\n     * @description\r\n     * Given a class constructor, returns the original constructor of it prior to any class level\r\n     * proxying by annotations declared through {@link @smartutils.services:AnnotationService AnnotationService}\r\n     *\r\n     * @param {Class} target the constructor\r\n     */\r\n    getOriginalConstructor(target: any): Class;\r\n    private getClassAnnotationsLogic;\r\n    private getMethodAnnotationsLogic;\r\n}\r\nexport declare const annotationService: AnnotationService;\r\n"}}
