{"code":"import { __decorate, __metadata } from \"tslib\";\r\n/*\r\n * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.\r\n */\r\nimport { Injectable } from '@angular/core';\r\nimport * as lodash from 'lodash';\r\nimport { IDecoratorService, ILegacyDecoratorToCustomElementConverter, PromiseUtils, SeDowngradeService, StringUtils } from 'smarteditcommons';\r\n/**\r\n * This service enables and disables decorators. It also maps decorators to SmartEdit component typesâ€“regardless if they are enabled or disabled.\r\n *\r\n */\r\nvar /* @ngInject */ DecoratorService = /** @class */ (function () {\r\n    function /* @ngInject */ DecoratorService(promiseUtils, stringUtils, legacyDecoratorToCustomElementConverter) {\r\n        this.promiseUtils = promiseUtils;\r\n        this.stringUtils = stringUtils;\r\n        this.legacyDecoratorToCustomElementConverter = legacyDecoratorToCustomElementConverter;\r\n        this._activeDecorators = {};\r\n        this.componentDecoratorsMap = {};\r\n    }\r\n    /**\r\n     * This method enables a list of decorators for a group of component types.\r\n     * The list to be [enable]{@link DecoratorService#enable} is identified by a matching pattern.\r\n     * The list is enabled when a perspective or referenced perspective that it is bound to is activated/enabled.\r\n     *\r\n     *\r\n     *\r\n     *      decoratorService.addMappings({\r\n     *          '*Suffix': ['decorator1', 'decorator2'],\r\n     *          '.*Suffix': ['decorator2', 'decorator3'],\r\n     *          'MyExactType': ['decorator3', 'decorator4'],\r\n     *          '^((?!Middle).)*$': ['decorator4', 'decorator5']\r\n     *      });\r\n     *\r\n     *\r\n     * @param  map A key-map value; the key is the matching pattern and the value is an array of decorator keys. The key can be an exact type, an ant-like wild card, or a full regular expression:\r\n     */\r\n    /* @ngInject */ DecoratorService.prototype.addMappings = function (map) {\r\n        for (var regexpKey in map) {\r\n            if (map.hasOwnProperty(regexpKey)) {\r\n                var decoratorsArray = map[regexpKey];\r\n                this.legacyDecoratorToCustomElementConverter.convertIfNeeded(decoratorsArray);\r\n                this.componentDecoratorsMap[regexpKey] = lodash.union(this.componentDecoratorsMap[regexpKey] || [], decoratorsArray);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Enables a decorator\r\n     *\r\n     * @param decoratorKey The key that uniquely identifies the decorator.\r\n     * @param displayCondition Returns a promise that will resolve to a boolean that determines whether the decorator will be displayed.\r\n     */\r\n    /* @ngInject */ DecoratorService.prototype.enable = function (decoratorKey, displayCondition) {\r\n        if (!(decoratorKey in this._activeDecorators)) {\r\n            this._activeDecorators[decoratorKey] = {\r\n                displayCondition: displayCondition\r\n            };\r\n        }\r\n    };\r\n    /**\r\n     * Disables a decorator\r\n     *\r\n     * @param decoratorKey the decorator key\r\n     */\r\n    /* @ngInject */ DecoratorService.prototype.disable = function (decoratorKey) {\r\n        if (this._activeDecorators[decoratorKey]) {\r\n            delete this._activeDecorators[decoratorKey];\r\n        }\r\n    };\r\n    /**\r\n     * This method retrieves a list of decorator keys that is eligible for the specified component type.\r\n     * The list retrieved depends on which perspective is active.\r\n     *\r\n     * This method uses the list of decorators enabled by the [addMappings]{@link DecoratorService#addMappings} method.\r\n     *\r\n     * @param componentType The type of the component to be decorated.\r\n     * @param componentId The id of the component to be decorated.\r\n     * @returns A promise that resolves to a list of decorator keys.\r\n     *\r\n     */\r\n    /* @ngInject */ DecoratorService.prototype.getDecoratorsForComponent = function (componentType, componentId) {\r\n        var _this = this;\r\n        var decoratorArray = [];\r\n        if (this.componentDecoratorsMap) {\r\n            for (var regexpKey in this.componentDecoratorsMap) {\r\n                if (this.stringUtils.regExpFactory(regexpKey).test(componentType)) {\r\n                    decoratorArray = lodash.union(decoratorArray, this.componentDecoratorsMap[regexpKey]);\r\n                }\r\n            }\r\n        }\r\n        var promisesToResolve = [];\r\n        var displayedDecorators = [];\r\n        decoratorArray.forEach(function (dec) {\r\n            var activeDecorator = _this._activeDecorators[dec];\r\n            if (activeDecorator && activeDecorator.displayCondition) {\r\n                if (typeof activeDecorator.displayCondition !== 'function') {\r\n                    throw new Error(\"The active decorator's displayCondition property must be a function and must return a boolean\");\r\n                }\r\n                var deferred_1 = _this.promiseUtils.defer();\r\n                activeDecorator\r\n                    .displayCondition(componentType, componentId)\r\n                    .then(function (display) {\r\n                    if (display) {\r\n                        deferred_1.resolve(dec);\r\n                    }\r\n                    else {\r\n                        deferred_1.resolve(null);\r\n                    }\r\n                });\r\n                promisesToResolve.push(deferred_1.promise);\r\n            }\r\n            else if (activeDecorator) {\r\n                displayedDecorators.push(dec);\r\n            }\r\n        });\r\n        return Promise.all(promisesToResolve).then(function (decoratorsEnabled) {\r\n            return displayedDecorators.concat(decoratorsEnabled.filter(function (dec) { return dec; }));\r\n        });\r\n    };\r\n    /* @ngInject */ DecoratorService = __decorate([\r\n        SeDowngradeService(IDecoratorService),\r\n        Injectable(),\r\n        __metadata(\"design:paramtypes\", [PromiseUtils,\r\n            StringUtils,\r\n            ILegacyDecoratorToCustomElementConverter])\r\n    ], /* @ngInject */ DecoratorService);\r\n    return /* @ngInject */ DecoratorService;\r\n}());\r\nexport { /* @ngInject */ DecoratorService };\r\n//# sourceMappingURL=DecoratorService.js.map","references":["/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedittools/common/temp/node_modules/.pnpm/@angular/core@8.2.14_rxjs@6.5.4+zone.js@0.9.1/node_modules/@angular/core/core.d.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedittools/common/temp/node_modules/.pnpm/@types/lodash@4.14.159/node_modules/@types/lodash/ts3.1/index.d.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/dist/index.d.ts"],"map":"{\"version\":3,\"file\":\"DecoratorService.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/services/DecoratorService.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit/services/DecoratorService.d.ts","writeByteOrderMark":false,"text":"import { IDecoratorDisplayCondition, IDecoratorService, ILegacyDecoratorToCustomElementConverter, PromiseUtils, StringUtils } from 'smarteditcommons';\r\nexport interface DecoratorMapping {\r\n    [index: string]: string[];\r\n}\r\n/**\r\n * This service enables and disables decorators. It also maps decorators to SmartEdit component typesâ€“regardless if they are enabled or disabled.\r\n *\r\n */\r\nexport declare class DecoratorService implements IDecoratorService {\r\n    private promiseUtils;\r\n    private stringUtils;\r\n    private legacyDecoratorToCustomElementConverter;\r\n    private _activeDecorators;\r\n    private componentDecoratorsMap;\r\n    constructor(promiseUtils: PromiseUtils, stringUtils: StringUtils, legacyDecoratorToCustomElementConverter: ILegacyDecoratorToCustomElementConverter);\r\n    /**\r\n     * This method enables a list of decorators for a group of component types.\r\n     * The list to be [enable]{@link DecoratorService#enable} is identified by a matching pattern.\r\n     * The list is enabled when a perspective or referenced perspective that it is bound to is activated/enabled.\r\n     *\r\n     *\r\n     *\r\n     *      decoratorService.addMappings({\r\n     *          '*Suffix': ['decorator1', 'decorator2'],\r\n     *          '.*Suffix': ['decorator2', 'decorator3'],\r\n     *          'MyExactType': ['decorator3', 'decorator4'],\r\n     *          '^((?!Middle).)*$': ['decorator4', 'decorator5']\r\n     *      });\r\n     *\r\n     *\r\n     * @param  map A key-map value; the key is the matching pattern and the value is an array of decorator keys. The key can be an exact type, an ant-like wild card, or a full regular expression:\r\n     */\r\n    addMappings(map: DecoratorMapping): void;\r\n    /**\r\n     * Enables a decorator\r\n     *\r\n     * @param decoratorKey The key that uniquely identifies the decorator.\r\n     * @param displayCondition Returns a promise that will resolve to a boolean that determines whether the decorator will be displayed.\r\n     */\r\n    enable(decoratorKey: string, displayCondition?: IDecoratorDisplayCondition): void;\r\n    /**\r\n     * Disables a decorator\r\n     *\r\n     * @param decoratorKey the decorator key\r\n     */\r\n    disable(decoratorKey: string): void;\r\n    /**\r\n     * This method retrieves a list of decorator keys that is eligible for the specified component type.\r\n     * The list retrieved depends on which perspective is active.\r\n     *\r\n     * This method uses the list of decorators enabled by the [addMappings]{@link DecoratorService#addMappings} method.\r\n     *\r\n     * @param componentType The type of the component to be decorated.\r\n     * @param componentId The id of the component to be decorated.\r\n     * @returns A promise that resolves to a list of decorator keys.\r\n     *\r\n     */\r\n    getDecoratorsForComponent(componentType: string, componentId?: string): Promise<string[]>;\r\n}\r\n"}}
