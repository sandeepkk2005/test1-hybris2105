{"code":"import { __decorate, __extends, __metadata } from \"tslib\";\r\n/*\r\n * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.\r\n */\r\nimport { CrossFrameEventService, EVENT_PERSPECTIVE_CHANGED, EVENTS, GatewayProxied, IPermissionService, LogService, SeDowngradeService, SystemEventService } from 'smarteditcommons';\r\n/**\r\n * The name used to register the default rule.\r\n */\r\nexport var DEFAULT_DEFAULT_RULE_NAME = 'se.permission.service.default.rule';\r\nvar /* @ngInject */ PermissionService = /** @class */ (function (_super) {\r\n    __extends(/* @ngInject */ PermissionService, _super);\r\n    function /* @ngInject */ PermissionService(logService, systemEventService, crossFrameEventService) {\r\n        var _this = _super.call(this) || this;\r\n        _this.logService = logService;\r\n        _this.systemEventService = systemEventService;\r\n        _this.crossFrameEventService = crossFrameEventService;\r\n        _this._registerEventHandlers();\r\n        return _this;\r\n    }\r\n    /* @ngInject */ PermissionService_1 = /* @ngInject */ PermissionService;\r\n    /* @ngInject */ PermissionService.resetForTests = function () {\r\n        /* @ngInject */ PermissionService_1.rules = [];\r\n        /* @ngInject */ PermissionService_1.permissionsRegistry = [];\r\n        /* @ngInject */ PermissionService_1.cachedResults = {};\r\n    };\r\n    /* @ngInject */ PermissionService.hasCacheRegion = function (ruleName) {\r\n        return /* @ngInject */ PermissionService_1.cachedResults.hasOwnProperty(ruleName);\r\n    };\r\n    /* @ngInject */ PermissionService.getCacheRegion = function (ruleName) {\r\n        return /* @ngInject */ PermissionService_1.cachedResults[ruleName];\r\n    };\r\n    /* @ngInject */ PermissionService.prototype.getPermission = function (permissionName) {\r\n        return /* @ngInject */ PermissionService_1.permissionsRegistry.find(function (permission) { return permission.aliases.indexOf(permissionName) > -1; });\r\n    };\r\n    /* @ngInject */ PermissionService.prototype.unregisterDefaultRule = function () {\r\n        var defaultRule = this._getRule(DEFAULT_DEFAULT_RULE_NAME);\r\n        if (defaultRule) {\r\n            /* @ngInject */ PermissionService_1.rules.splice(/* @ngInject */ PermissionService_1.rules.indexOf(defaultRule), 1);\r\n        }\r\n    };\r\n    /* @ngInject */ PermissionService.prototype.registerPermission = function (permission) {\r\n        this._validatePermission(permission);\r\n        /* @ngInject */ PermissionService_1.permissionsRegistry.push({\r\n            aliases: permission.aliases,\r\n            rules: permission.rules\r\n        });\r\n    };\r\n    /* @ngInject */ PermissionService.prototype.hasCachedResult = function (ruleName, key) {\r\n        return (/* @ngInject */ PermissionService_1.hasCacheRegion(ruleName) &&\r\n            /* @ngInject */ PermissionService_1.getCacheRegion(ruleName).hasOwnProperty(key));\r\n    };\r\n    /* @ngInject */ PermissionService.prototype.clearCache = function () {\r\n        /* @ngInject */ PermissionService_1.cachedResults = {};\r\n        this.crossFrameEventService.publish(EVENTS.PERMISSION_CACHE_CLEANED);\r\n    };\r\n    /* @ngInject */ PermissionService.prototype.isPermitted = function (permissions) {\r\n        var _this = this;\r\n        var rulePermissionNames = this._mapRuleNameToPermissionNames(permissions);\r\n        var rulePromises = this._getRulePromises(rulePermissionNames);\r\n        var names = Object.keys(rulePromises);\r\n        var promises = names.map(function (key) { return rulePromises[key]; });\r\n        var onSuccess = function (permissionResults) {\r\n            var result = names.reduce(function (acc, name, index) {\r\n                acc[name] = permissionResults[index];\r\n                return acc;\r\n            }, {});\r\n            _this._updateCache(rulePermissionNames, result);\r\n            return true;\r\n        };\r\n        var onError = function (result) {\r\n            if (result === false) {\r\n                return result;\r\n            }\r\n            _this.logService.error(result);\r\n            return result === undefined ? false : result;\r\n        };\r\n        return Promise.all(promises).then(onSuccess, onError);\r\n    };\r\n    /**\r\n     * This method adds a promise obtained by calling the pre-configured rule.verify function to the rulePromises\r\n     * map if the result does not exist in the rule's cache. Otherwise, a promise that contains the cached result\r\n     * is added.\r\n     *\r\n     * The promise obtained from the rule.verify function is chained to allow short-circuiting the permission\r\n     * verification process. If a rule resolves with a false result or with an error, the chained promise is\r\n     * rejected to stop the verification process without waiting for all other rules to resolve.\r\n     *\r\n     * @param rulePromises An object that maps rule names to promises.\r\n     * @param rulePermissionNames An object that maps rule names to permission name arrays.\r\n     * @param ruleName The name of the rule to verify.\r\n     */\r\n    /* @ngInject */ PermissionService.prototype._addRulePromise = function (rulePromises, rulePermissionNames, ruleName) {\r\n        var rule = this._getRule(ruleName);\r\n        var permissionNameObjs = rulePermissionNames[ruleName];\r\n        var cacheKey = this._generateCacheKey(permissionNameObjs);\r\n        var rulePromise;\r\n        if (this.hasCachedResult(ruleName, cacheKey)) {\r\n            rulePromise = Promise.resolve(this._getCachedResult(ruleName, cacheKey));\r\n        }\r\n        else {\r\n            rulePromise = this._callRuleVerify(rule.names.join('-'), permissionNameObjs).then(function (isPermitted) {\r\n                return isPermitted ? Promise.resolve(true) : Promise.reject(false);\r\n            });\r\n        }\r\n        rulePromises[ruleName] = rulePromise;\r\n    };\r\n    /**\r\n     * This method validates a permission name. Permission names need to be prefixed by at least one\r\n     * namespace followed by a \".\" character to be valid.\r\n     *\r\n     * Example: se.mynamespace is valid.\r\n     * Example: mynamespace is not valid.\r\n     */\r\n    /* @ngInject */ PermissionService.prototype._isPermissionNameValid = function (permissionName) {\r\n        var checkNameSpace = /^[A-Za-z0-9_\\-]+\\.[A-Za-z0-9_\\-\\.]+/;\r\n        return checkNameSpace.test(permissionName);\r\n    };\r\n    /**\r\n     * This method returns an object that maps rule names to promises.\r\n     */\r\n    /* @ngInject */ PermissionService.prototype._getRulePromises = function (rulePermissionNames) {\r\n        var _this = this;\r\n        var rulePromises = {};\r\n        Object.keys(rulePermissionNames).forEach(function (ruleName) {\r\n            _this._addRulePromise.call(_this, rulePromises, rulePermissionNames, ruleName);\r\n        });\r\n        return rulePromises;\r\n    };\r\n    /**\r\n     * This method returns true if a default rule is already registered.\r\n     *\r\n     * @returns true if the default rule has been registered, false otherwise.\r\n     */\r\n    /* @ngInject */ PermissionService.prototype._hasDefaultRule = function () {\r\n        return !!this._getRule(DEFAULT_DEFAULT_RULE_NAME);\r\n    };\r\n    /**\r\n     * This method returns the rule's cached result for the given key.\r\n     *\r\n     * @param ruleName The name of the rule for which to lookup the cached result.\r\n     * @param key The cached key to lookup..\r\n     *\r\n     * @returns The cached result, if it exists, null otherwise.\r\n     */\r\n    /* @ngInject */ PermissionService.prototype._getCachedResult = function (ruleName, key) {\r\n        return /* @ngInject */ PermissionService_1.hasCacheRegion(ruleName)\r\n            ? /* @ngInject */ PermissionService_1.getCacheRegion(ruleName)[key]\r\n            : null;\r\n    };\r\n    /**\r\n     * This method generates a key to store a rule's result for a given combination of\r\n     * permissions in its cache. It is done by sorting the list of permissions by name\r\n     * and serializing it.\r\n     *\r\n     * @param permissions A list of permissions with a name and context.\r\n     *\r\n     * [{\r\n     *     name: \"permission.name\"\r\n     *     context: {\r\n     *         key: \"value\"\r\n     *     }\r\n     * }]\r\n     *\r\n     * @returns The serialized sorted list of permissions.\r\n     */\r\n    /* @ngInject */ PermissionService.prototype._generateCacheKey = function (permissions) {\r\n        return JSON.stringify(permissions.sort(function (permissionA, permissionB) {\r\n            var nameA = permissionA.name;\r\n            var nameB = permissionB.name;\r\n            return nameA === nameB ? 0 : nameA < nameB ? -1 : 1;\r\n        }));\r\n    };\r\n    /**\r\n     * This method goes through the permission name arrays associated to rule names to remove any duplicate\r\n     * permission names.\r\n     *\r\n     * If one or more permission names with the same context are found in a rule name's permission name array,\r\n     * only one entry is kept.\r\n     */\r\n    /* @ngInject */ PermissionService.prototype._removeDuplicatePermissionNames = function (rulePermissionNames) {\r\n        Object.keys(rulePermissionNames).forEach(function (ruleName) {\r\n            rulePermissionNames[ruleName] = rulePermissionNames[ruleName].filter(function (currentPermission) {\r\n                var existingPermission = rulePermissionNames[ruleName].find(function (permission) { return permission.name === currentPermission.name; });\r\n                if (existingPermission === currentPermission) {\r\n                    return true;\r\n                }\r\n                else {\r\n                    var existingPermissionContext = existingPermission.context;\r\n                    var currentPermissionContext = currentPermission.context;\r\n                    return (JSON.stringify(existingPermissionContext) !==\r\n                        JSON.stringify(currentPermissionContext));\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * This method returns an object mapping rule name to permission name arrays.\r\n     *\r\n     * It will iterate through the given permission name object array to extract the permission names and contexts,\r\n     * populate the map and clean it up by removing duplicate permission name and context pairs.\r\n     */\r\n    /* @ngInject */ PermissionService.prototype._mapRuleNameToPermissionNames = function (permissions) {\r\n        var _this = this;\r\n        var rulePermissionNames = {};\r\n        permissions.forEach(function (permission) {\r\n            if (!permission.names) {\r\n                throw Error('Requested Permission requires at least one name');\r\n            }\r\n            var permissionNames = permission.names;\r\n            var permissionContext = permission.context;\r\n            permissionNames.forEach(function (permissionName) {\r\n                _this._populateRulePermissionNames(rulePermissionNames, permissionName, permissionContext);\r\n            });\r\n        });\r\n        this._removeDuplicatePermissionNames(rulePermissionNames);\r\n        return rulePermissionNames;\r\n    };\r\n    /**\r\n     * This method will populate rulePermissionNames with the rules associated to the permission with the given\r\n     * permissionName.\r\n     *\r\n     * If no permission is registered with the given permissionName and a default rule is registered, the default\r\n     * rule is added to rulePermissionNames.\r\n     *\r\n     * If no permission is registered with the given permissionName and no default rule is registered, an error\r\n     * is thrown.\r\n     */\r\n    /* @ngInject */ PermissionService.prototype._populateRulePermissionNames = function (rulePermissionNames, permissionName, permissionContext) {\r\n        var _this = this;\r\n        var permission = this.getPermission(permissionName);\r\n        var permissionHasRules = !!permission && !!permission.rules && permission.rules.length > 0;\r\n        if (permissionHasRules) {\r\n            permission.rules.forEach(function (ruleName) {\r\n                _this._addPermissionName(rulePermissionNames, ruleName, permissionName, permissionContext);\r\n            });\r\n        }\r\n        else if (this._hasDefaultRule()) {\r\n            this._addPermissionName(rulePermissionNames, DEFAULT_DEFAULT_RULE_NAME, permissionName, permissionContext);\r\n        }\r\n        else {\r\n            throw Error('Permission has no rules');\r\n        }\r\n    };\r\n    /**\r\n     * This method will add an object with the permissionName and permissionContext to rulePermissionNames.\r\n     *\r\n     * Since rules can have multiple names, the map will use the first name in the rule's name list as its key.\r\n     * This way, each rule will be called only once for every permission name and context.\r\n     *\r\n     * If the rule associated to a given rule name is already in rulePermissionNames, the permission will be\r\n     * appended to the associated array. Otherwise, the rule name is added to the map and its permission name array\r\n     * is created.\r\n     */\r\n    /* @ngInject */ PermissionService.prototype._addPermissionName = function (rulePermissionNames, ruleName, permissionName, permissionContext) {\r\n        var rule = this._getRule(ruleName);\r\n        if (!rule) {\r\n            throw Error('Permission found but no rule found named: ' + ruleName);\r\n        }\r\n        ruleName = rule.names[0];\r\n        if (!rulePermissionNames.hasOwnProperty(ruleName)) {\r\n            rulePermissionNames[ruleName] = [];\r\n        }\r\n        rulePermissionNames[ruleName].push({\r\n            name: permissionName,\r\n            context: permissionContext\r\n        });\r\n    };\r\n    /**\r\n     * This method returns the rule registered with the given name.\r\n     *\r\n     * @param ruleName The name of the rule to lookup.\r\n     *\r\n     * @returns rule The rule with the given name, undefined otherwise.\r\n     */\r\n    /* @ngInject */ PermissionService.prototype._getRule = function (ruleName) {\r\n        return /* @ngInject */ PermissionService_1.rules.find(function (rule) { return rule.names.indexOf(ruleName) > -1; });\r\n    };\r\n    /* @ngInject */ PermissionService.prototype._validationRule = function (ruleConfiguration) {\r\n        var _this = this;\r\n        ruleConfiguration.names.forEach(function (ruleName) {\r\n            if (_this._getRule(ruleName)) {\r\n                throw Error('Rule already exists: ' + ruleName);\r\n            }\r\n        });\r\n    };\r\n    /* @ngInject */ PermissionService.prototype._validatePermission = function (permissionConfiguration) {\r\n        var _this = this;\r\n        if (!(permissionConfiguration.aliases instanceof Array)) {\r\n            throw Error('Permission aliases must be an array');\r\n        }\r\n        if (permissionConfiguration.aliases.length < 1) {\r\n            throw Error('Permission requires at least one alias');\r\n        }\r\n        if (!(permissionConfiguration.rules instanceof Array)) {\r\n            throw Error('Permission rules must be an array');\r\n        }\r\n        if (permissionConfiguration.rules.length < 1) {\r\n            throw Error('Permission requires at least one rule');\r\n        }\r\n        permissionConfiguration.aliases.forEach(function (permissionName) {\r\n            if (_this.getPermission(permissionName)) {\r\n                throw Error('Permission already exists: ' + permissionName);\r\n            }\r\n            if (!_this._isPermissionNameValid(permissionName)) {\r\n                throw Error('Permission aliases must be prefixed with namespace and a full stop');\r\n            }\r\n        });\r\n        permissionConfiguration.rules.forEach(function (ruleName) {\r\n            if (!_this._getRule(ruleName)) {\r\n                throw Error('Permission found but no rule found named: ' + ruleName);\r\n            }\r\n        });\r\n    };\r\n    /* @ngInject */ PermissionService.prototype._updateCache = function (rulePermissionNames, permissionResults) {\r\n        var _this = this;\r\n        Object.keys(permissionResults).forEach(function (ruleName) {\r\n            var cacheKey = _this._generateCacheKey(rulePermissionNames[ruleName]);\r\n            var cacheValue = permissionResults[ruleName];\r\n            _this._addCachedResult(ruleName, cacheKey, cacheValue);\r\n        });\r\n    };\r\n    /* @ngInject */ PermissionService.prototype._addCachedResult = function (ruleName, key, result) {\r\n        if (!/* @ngInject */ PermissionService_1.hasCacheRegion(ruleName)) {\r\n            /* @ngInject */ PermissionService_1.cachedResults[ruleName] = {};\r\n        }\r\n        /* @ngInject */ PermissionService_1.cachedResults[ruleName][key] = result;\r\n    };\r\n    /* @ngInject */ PermissionService.prototype._registerRule = function (ruleConfiguration) {\r\n        this._validationRule(ruleConfiguration);\r\n        if (ruleConfiguration.names &&\r\n            ruleConfiguration.names.length &&\r\n            ruleConfiguration.names.indexOf(DEFAULT_DEFAULT_RULE_NAME) > -1) {\r\n            throw Error('Register default rule using permissionService.registerDefaultRule()');\r\n        }\r\n        /* @ngInject */ PermissionService_1.rules.push({\r\n            names: ruleConfiguration.names\r\n        });\r\n    };\r\n    /* @ngInject */ PermissionService.prototype._registerDefaultRule = function (ruleConfiguration) {\r\n        this._validationRule(ruleConfiguration);\r\n        if (ruleConfiguration.names &&\r\n            ruleConfiguration.names.length &&\r\n            ruleConfiguration.names.indexOf(DEFAULT_DEFAULT_RULE_NAME) === -1) {\r\n            throw Error('Default rule name must be DEFAULT_RULE_NAME');\r\n        }\r\n        /* @ngInject */ PermissionService_1.rules.push({\r\n            names: ruleConfiguration.names\r\n        });\r\n    };\r\n    /* @ngInject */ PermissionService.prototype._callRuleVerify = function (ruleKey, permissionNameObjs) {\r\n        if (this.ruleVerifyFunctions && this.ruleVerifyFunctions[ruleKey]) {\r\n            return this.ruleVerifyFunctions[ruleKey].verify(permissionNameObjs);\r\n        }\r\n        // ask inner application for verify function.\r\n        return this._remoteCallRuleVerify(ruleKey, permissionNameObjs);\r\n    };\r\n    /* @ngInject */ PermissionService.prototype._registerEventHandlers = function () {\r\n        this.crossFrameEventService.subscribe(EVENTS.USER_HAS_CHANGED, this.clearCache.bind(this));\r\n        this.systemEventService.subscribe(EVENTS.EXPERIENCE_UPDATE, this.clearCache.bind(this));\r\n        this.crossFrameEventService.subscribe(EVENTS.PAGE_CHANGE, this.clearCache.bind(this));\r\n        this.crossFrameEventService.subscribe(EVENT_PERSPECTIVE_CHANGED, this.clearCache.bind(this));\r\n    };\r\n    /* @ngInject */ PermissionService.prototype._remoteCallRuleVerify = function (name, permissionNameObjs) {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    var /* @ngInject */ PermissionService_1;\r\n    /* @ngInject */ PermissionService.rules = [];\r\n    /* @ngInject */ PermissionService.permissionsRegistry = [];\r\n    /* @ngInject */ PermissionService.cachedResults = {};\r\n    /* @ngInject */ PermissionService = /* @ngInject */ PermissionService_1 = __decorate([\r\n        SeDowngradeService(IPermissionService),\r\n        GatewayProxied('isPermitted', 'clearCache', 'registerPermission', 'unregisterDefaultRule', 'registerDefaultRule', 'registerRule', '_registerRule', '_remoteCallRuleVerify', '_registerDefaultRule'),\r\n        __metadata(\"design:paramtypes\", [LogService,\r\n            SystemEventService,\r\n            CrossFrameEventService])\r\n    ], /* @ngInject */ PermissionService);\r\n    return /* @ngInject */ PermissionService;\r\n}(IPermissionService));\r\nexport { /* @ngInject */ PermissionService };\r\n//# sourceMappingURL=PermissionServiceOuter.js.map","references":["/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/dist/index.d.ts"],"map":"{\"version\":3,\"file\":\"PermissionServiceOuter.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/services/PermissionServiceOuter.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-container/services/PermissionServiceOuter.d.ts","writeByteOrderMark":false,"text":"import { CrossFrameEventService, IPermissionService, LogService, MultiNamePermissionContext, Permission, PermissionContext, Rule, RuleNames, SystemEventService, TypedMap } from 'smarteditcommons';\r\n/**\r\n * The name used to register the default rule.\r\n */\r\nexport declare const DEFAULT_DEFAULT_RULE_NAME = \"se.permission.service.default.rule\";\r\nexport declare type RulePermissionNames = TypedMap<PermissionContext[]>;\r\nexport declare class PermissionService extends IPermissionService {\r\n    private logService;\r\n    private systemEventService;\r\n    private crossFrameEventService;\r\n    private static rules;\r\n    private static permissionsRegistry;\r\n    private static cachedResults;\r\n    static resetForTests(): void;\r\n    private static hasCacheRegion;\r\n    private static getCacheRegion;\r\n    constructor(logService: LogService, systemEventService: SystemEventService, crossFrameEventService: CrossFrameEventService);\r\n    getPermission(permissionName: string): Permission;\r\n    unregisterDefaultRule(): void;\r\n    registerPermission(permission: Permission): void;\r\n    hasCachedResult(ruleName: string, key: string): boolean;\r\n    clearCache(): void;\r\n    isPermitted(permissions: MultiNamePermissionContext[]): Promise<boolean>;\r\n    /**\r\n     * This method adds a promise obtained by calling the pre-configured rule.verify function to the rulePromises\r\n     * map if the result does not exist in the rule's cache. Otherwise, a promise that contains the cached result\r\n     * is added.\r\n     *\r\n     * The promise obtained from the rule.verify function is chained to allow short-circuiting the permission\r\n     * verification process. If a rule resolves with a false result or with an error, the chained promise is\r\n     * rejected to stop the verification process without waiting for all other rules to resolve.\r\n     *\r\n     * @param rulePromises An object that maps rule names to promises.\r\n     * @param rulePermissionNames An object that maps rule names to permission name arrays.\r\n     * @param ruleName The name of the rule to verify.\r\n     */\r\n    protected _addRulePromise(rulePromises: TypedMap<Promise<boolean>>, rulePermissionNames: RulePermissionNames, ruleName: string): void;\r\n    /**\r\n     * This method validates a permission name. Permission names need to be prefixed by at least one\r\n     * namespace followed by a \".\" character to be valid.\r\n     *\r\n     * Example: se.mynamespace is valid.\r\n     * Example: mynamespace is not valid.\r\n     */\r\n    protected _isPermissionNameValid(permissionName: string): boolean;\r\n    /**\r\n     * This method returns an object that maps rule names to promises.\r\n     */\r\n    protected _getRulePromises(rulePermissionNames: RulePermissionNames): TypedMap<Promise<boolean>>;\r\n    /**\r\n     * This method returns true if a default rule is already registered.\r\n     *\r\n     * @returns true if the default rule has been registered, false otherwise.\r\n     */\r\n    protected _hasDefaultRule(): boolean;\r\n    /**\r\n     * This method returns the rule's cached result for the given key.\r\n     *\r\n     * @param ruleName The name of the rule for which to lookup the cached result.\r\n     * @param key The cached key to lookup..\r\n     *\r\n     * @returns The cached result, if it exists, null otherwise.\r\n     */\r\n    protected _getCachedResult(ruleName: string, key: string): boolean | null;\r\n    /**\r\n     * This method generates a key to store a rule's result for a given combination of\r\n     * permissions in its cache. It is done by sorting the list of permissions by name\r\n     * and serializing it.\r\n     *\r\n     * @param permissions A list of permissions with a name and context.\r\n     *\r\n     * [{\r\n     *     name: \"permission.name\"\r\n     *     context: {\r\n     *         key: \"value\"\r\n     *     }\r\n     * }]\r\n     *\r\n     * @returns The serialized sorted list of permissions.\r\n     */\r\n    protected _generateCacheKey(permissions: PermissionContext[]): string;\r\n    /**\r\n     * This method goes through the permission name arrays associated to rule names to remove any duplicate\r\n     * permission names.\r\n     *\r\n     * If one or more permission names with the same context are found in a rule name's permission name array,\r\n     * only one entry is kept.\r\n     */\r\n    protected _removeDuplicatePermissionNames(rulePermissionNames: RulePermissionNames): void;\r\n    /**\r\n     * This method returns an object mapping rule name to permission name arrays.\r\n     *\r\n     * It will iterate through the given permission name object array to extract the permission names and contexts,\r\n     * populate the map and clean it up by removing duplicate permission name and context pairs.\r\n     */\r\n    protected _mapRuleNameToPermissionNames(permissions: MultiNamePermissionContext[]): TypedMap<PermissionContext[]>;\r\n    /**\r\n     * This method will populate rulePermissionNames with the rules associated to the permission with the given\r\n     * permissionName.\r\n     *\r\n     * If no permission is registered with the given permissionName and a default rule is registered, the default\r\n     * rule is added to rulePermissionNames.\r\n     *\r\n     * If no permission is registered with the given permissionName and no default rule is registered, an error\r\n     * is thrown.\r\n     */\r\n    protected _populateRulePermissionNames(rulePermissionNames: RulePermissionNames, permissionName: string, permissionContext: TypedMap<string>): void;\r\n    /**\r\n     * This method will add an object with the permissionName and permissionContext to rulePermissionNames.\r\n     *\r\n     * Since rules can have multiple names, the map will use the first name in the rule's name list as its key.\r\n     * This way, each rule will be called only once for every permission name and context.\r\n     *\r\n     * If the rule associated to a given rule name is already in rulePermissionNames, the permission will be\r\n     * appended to the associated array. Otherwise, the rule name is added to the map and its permission name array\r\n     * is created.\r\n     */\r\n    protected _addPermissionName(rulePermissionNames: RulePermissionNames, ruleName: string, permissionName: string, permissionContext: TypedMap<any>): void;\r\n    /**\r\n     * This method returns the rule registered with the given name.\r\n     *\r\n     * @param ruleName The name of the rule to lookup.\r\n     *\r\n     * @returns rule The rule with the given name, undefined otherwise.\r\n     */\r\n    protected _getRule(ruleName: string): RuleNames;\r\n    protected _validationRule(ruleConfiguration: Rule): void;\r\n    protected _validatePermission(permissionConfiguration: Permission): void;\r\n    protected _updateCache(rulePermissionNames: RulePermissionNames, permissionResults: TypedMap<boolean>): void;\r\n    protected _addCachedResult(ruleName: string, key: string, result: boolean): void;\r\n    protected _registerRule(ruleConfiguration: Rule): void;\r\n    protected _registerDefaultRule(ruleConfiguration: Rule): void;\r\n    protected _callRuleVerify(ruleKey: string, permissionNameObjs: PermissionContext[]): Promise<boolean>;\r\n    protected _registerEventHandlers(): void;\r\n    protected _remoteCallRuleVerify(name: string, permissionNameObjs: PermissionContext[]): Promise<boolean>;\r\n}\r\n"}}
