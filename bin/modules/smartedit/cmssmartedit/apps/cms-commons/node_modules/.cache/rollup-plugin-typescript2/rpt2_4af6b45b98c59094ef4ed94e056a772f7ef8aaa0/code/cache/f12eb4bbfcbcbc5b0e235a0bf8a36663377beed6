{"code":"var IPageService = /** @class */ (function () {\r\n    function IPageService() {\r\n    }\r\n    /**\r\n     * Retrieves the page corresponding to the given page UID in the current contextual\r\n     * site + catalog + catalog version.\r\n     */\r\n    IPageService.prototype.getPageById = function (pageUid) {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    /**\r\n     * Retrieves the page information of the page identified by the given uuid.\r\n     */\r\n    IPageService.prototype.getPageByUuid = function (pageUuid) {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    /**\r\n     * Retrieves the page information of the page that is currently loaded.\r\n     *\r\n     * @returns A promise that resolves to a CMS Item object containing\r\n     * information related to the current page\r\n     */\r\n    IPageService.prototype.getCurrentPageInfo = function () {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    /**\r\n     * Retrieves a version, as identified by the provided version id, of the page information that is currently loaded.\r\n     *\r\n     * @param versionId The ID of the page version to load.\r\n     *\r\n     * @returns A promise that resolves to a CMS Item object containing\r\n     * information related to the version selected of the current page\r\n     */\r\n    IPageService.prototype.getCurrentPageInfoByVersion = function (versionId) {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    /**\r\n     * Determines if a page belonging to the current contextual site+catalog+catalogversion is primary.\r\n     */\r\n    IPageService.prototype.isPagePrimary = function (pageUid) {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    /**\r\n     * Determines if a page belonging to the provided contextual site+catalog+catalogversion is primary.\r\n     *\r\n     * @param uriContext The uriContext for the pageId\r\n     */\r\n    IPageService.prototype.isPagePrimaryWithContext = function (pageUid, uriContext) {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    /**\r\n     * Retrieves the primary page of the given variation page in the current site+catalog+catalogversion.\r\n     *\r\n     * @param variationPageId The UID of the variation page for which to find its primary page.\r\n     *\r\n     * @returns A promise that resolves to the page object or undefined if no primary page was found.\r\n     */\r\n    IPageService.prototype.getPrimaryPage = function (variationPageUid) {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    /**\r\n     * Returns true if primary page exists for a given page type\r\n     */\r\n    IPageService.prototype.primaryPageForPageTypeExists = function (pageTypeCode, uriParams) {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    /**\r\n     * Fetches a pagination page for list of pages for a given site+catalog+catalogversion and page\r\n     * @returns A promise that resolves to pagination with array of pages\r\n     */\r\n    IPageService.prototype.getPaginatedPrimaryPagesForPageType = function (pageTypeCode, uriParams, fetchPageParams) {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    /**\r\n     * Retrieves the variation pages of the given primary page in the current site+catalog+catalogversion.\r\n     *\r\n     * @returns A promise that resolves an array of variation pages or an empty list if none are found.\r\n     */\r\n    IPageService.prototype.getVariationPages = function (primaryPageUid) {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    /**\r\n     * Updates the page corresponding to the given page UID with the payload provided for the current site+catalog+catalogversion.\r\n     *\r\n     * @returns A promise that resolves to the JSON page object as it now exists in the backend\r\n     */\r\n    IPageService.prototype.updatePageById = function (pageUid, payload) {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    /**\r\n     * This method will forcefully update the page approval status (as long as the current user has the right permissions) of the page loaded\r\n     * in the current context to the given status.\r\n     *\r\n     * @returns If request is successful, it returns a promise that resolves with the updated CMS Item object. If the\r\n     * request fails, it resolves with errors from the backend.\r\n     */\r\n    IPageService.prototype.forcePageApprovalStatus = function (newPageStatus) {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    /**\r\n     * This method is used to determine whether the given page is approved (and can be synched).\r\n     */\r\n    IPageService.prototype.isPageApproved = function (pageParam) {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    /**\r\n     * Returns the uriContext populated with the siteId, catalogId and catalogVersion taken from $routeParams and fallback to the currentExperience\r\n     * Note: From the page list, $routeParams are defined. From the storefront, $routeParams are undefined.\r\n     */\r\n    IPageService.prototype.buildUriContextForCurrentPage = function (siteId, catalogId, catalogVersion) {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    return IPageService;\r\n}());\r\nexport { IPageService };\r\n//# sourceMappingURL=IPageService.js.map","references":["/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/dist/index.d.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/cmssmartedit/apps/cms-commons/src/dao/index.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/cmssmartedit/apps/cms-commons/src/dtos/index.ts"],"map":"{\"version\":3,\"file\":\"IPageService.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/services/pages/IPageService.ts\"],\"names\":[],\"mappings\":\"AAOA;IAAA;IAyJA,CAAC;IAxJG;;;OAGG;IACI,kCAAW,GAAlB,UAAmB,OAAe;QAC9B,eAAe,CAAC;QAChB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;OAEG;IACI,oCAAa,GAApB,UAAqB,QAAgB;QACjC,eAAe,CAAC;QAChB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;;OAKG;IACI,yCAAkB,GAAzB;QACI,eAAe,CAAC;QAChB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;;;;OAOG;IACI,kDAA2B,GAAlC,UAAmC,SAAwB;QACvD,eAAe,CAAC;QAChB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;OAEG;IACI,oCAAa,GAApB,UAAqB,OAAe;QAChC,eAAe,CAAC;QAChB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;OAIG;IACI,+CAAwB,GAA/B,UAAgC,OAAe,EAAE,UAAuB;QACpE,eAAe,CAAC;QAChB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;;;OAMG;IACI,qCAAc,GAArB,UAAsB,gBAAwB;QAC1C,eAAe,CAAC;QAChB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;OAEG;IAEI,mDAA4B,GAAnC,UACI,YAAoB,EACpB,SAAuB;QAEvB,eAAe,CAAC;QAChB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;OAGG;IACI,0DAAmC,GAA1C,UACI,YAAoB,EACpB,SAAuB,EACvB,eAIC;QAED,eAAe,CAAC;QAChB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;OAIG;IACI,wCAAiB,GAAxB,UAAyB,cAAsB;QAC3C,eAAe,CAAC;QAChB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;OAIG;IACI,qCAAc,GAArB,UAAsB,OAAe,EAAE,OAAiB;QACpD,eAAe,CAAC;QAChB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;;;OAMG;IACI,8CAAuB,GAA9B,UAA+B,aAAgC;QAC3D,eAAe,CAAC;QAChB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;OAEG;IACI,qCAAc,GAArB,UAAsB,SAA4B;QAC9C,eAAe,CAAC;QAChB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;OAGG;IACI,oDAA6B,GAApC,UACI,MAAwB,EACxB,SAA2B,EAC3B,cAAgC;QAEhC,eAAe,CAAC;QAChB,OAAO,IAAI,CAAC;IAChB,CAAC;IACL,mBAAC;AAAD,CAAC,AAzJD,IAyJC\"}","dts":{"name":"/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/cmssmartedit/apps/cms-commons/services/pages/IPageService.d.ts","writeByteOrderMark":false,"text":"import { IUriContext, Nullable } from 'smarteditcommons';\r\nimport { Page } from '../../dao';\r\nimport { CmsApprovalStatus, ICMSPage } from '../../dtos';\r\nexport declare abstract class IPageService {\r\n    /**\r\n     * Retrieves the page corresponding to the given page UID in the current contextual\r\n     * site + catalog + catalog version.\r\n     */\r\n    getPageById(pageUid: string): Promise<ICMSPage>;\r\n    /**\r\n     * Retrieves the page information of the page identified by the given uuid.\r\n     */\r\n    getPageByUuid(pageUuid: string): Promise<ICMSPage>;\r\n    /**\r\n     * Retrieves the page information of the page that is currently loaded.\r\n     *\r\n     * @returns A promise that resolves to a CMS Item object containing\r\n     * information related to the current page\r\n     */\r\n    getCurrentPageInfo(): Promise<ICMSPage>;\r\n    /**\r\n     * Retrieves a version, as identified by the provided version id, of the page information that is currently loaded.\r\n     *\r\n     * @param versionId The ID of the page version to load.\r\n     *\r\n     * @returns A promise that resolves to a CMS Item object containing\r\n     * information related to the version selected of the current page\r\n     */\r\n    getCurrentPageInfoByVersion(versionId: string | null): Promise<ICMSPage>;\r\n    /**\r\n     * Determines if a page belonging to the current contextual site+catalog+catalogversion is primary.\r\n     */\r\n    isPagePrimary(pageUid: string): Promise<boolean>;\r\n    /**\r\n     * Determines if a page belonging to the provided contextual site+catalog+catalogversion is primary.\r\n     *\r\n     * @param uriContext The uriContext for the pageId\r\n     */\r\n    isPagePrimaryWithContext(pageUid: string, uriContext: IUriContext): Promise<boolean>;\r\n    /**\r\n     * Retrieves the primary page of the given variation page in the current site+catalog+catalogversion.\r\n     *\r\n     * @param variationPageId The UID of the variation page for which to find its primary page.\r\n     *\r\n     * @returns A promise that resolves to the page object or undefined if no primary page was found.\r\n     */\r\n    getPrimaryPage(variationPageUid: string): Promise<Nullable<ICMSPage>>;\r\n    /**\r\n     * Returns true if primary page exists for a given page type\r\n     */\r\n    primaryPageForPageTypeExists(pageTypeCode: string, uriParams?: IUriContext): Promise<boolean>;\r\n    /**\r\n     * Fetches a pagination page for list of pages for a given site+catalog+catalogversion and page\r\n     * @returns A promise that resolves to pagination with array of pages\r\n     */\r\n    getPaginatedPrimaryPagesForPageType(pageTypeCode: string, uriParams?: IUriContext, fetchPageParams?: {\r\n        search: string;\r\n        pageSize: number;\r\n        currentPage: number;\r\n    }): Promise<Page<ICMSPage>>;\r\n    /**\r\n     * Retrieves the variation pages of the given primary page in the current site+catalog+catalogversion.\r\n     *\r\n     * @returns A promise that resolves an array of variation pages or an empty list if none are found.\r\n     */\r\n    getVariationPages(primaryPageUid: string): Promise<ICMSPage[]>;\r\n    /**\r\n     * Updates the page corresponding to the given page UID with the payload provided for the current site+catalog+catalogversion.\r\n     *\r\n     * @returns A promise that resolves to the JSON page object as it now exists in the backend\r\n     */\r\n    updatePageById(pageUid: string, payload: ICMSPage): Promise<ICMSPage>;\r\n    /**\r\n     * This method will forcefully update the page approval status (as long as the current user has the right permissions) of the page loaded\r\n     * in the current context to the given status.\r\n     *\r\n     * @returns If request is successful, it returns a promise that resolves with the updated CMS Item object. If the\r\n     * request fails, it resolves with errors from the backend.\r\n     */\r\n    forcePageApprovalStatus(newPageStatus: CmsApprovalStatus): Promise<ICMSPage>;\r\n    /**\r\n     * This method is used to determine whether the given page is approved (and can be synched).\r\n     */\r\n    isPageApproved(pageParam: string | ICMSPage): Promise<boolean>;\r\n    /**\r\n     * Returns the uriContext populated with the siteId, catalogId and catalogVersion taken from $routeParams and fallback to the currentExperience\r\n     * Note: From the page list, $routeParams are defined. From the storefront, $routeParams are undefined.\r\n     */\r\n    buildUriContextForCurrentPage(siteId: Nullable<string>, catalogId: Nullable<string>, catalogVersion: Nullable<string>): Promise<IUriContext>;\r\n}\r\n"}}
