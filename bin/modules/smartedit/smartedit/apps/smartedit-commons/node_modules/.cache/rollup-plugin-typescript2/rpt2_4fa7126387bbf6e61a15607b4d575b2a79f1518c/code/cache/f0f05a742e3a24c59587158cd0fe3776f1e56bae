{"code":"//# sourceMappingURL=IStorage.js.map","references":["/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/dist/index.d.ts"],"map":"{\"version\":3,\"file\":\"IStorage.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/services/storage/IStorage.ts\"],\"names\":[],\"mappings\":\"\"}","dts":{"name":"/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/services/storage/IStorage.d.ts","writeByteOrderMark":false,"text":"import { Cloneable } from '@smart/utils';\r\n/**\r\n *  Represents a data access point, but depending on the implementation doesn't\r\n *  necessarily contain the stored data directly. For example a cloud storage implementation might access the remote\r\n *  storage via REST on a get(), or it might fetch the whole storage and keep it in memory.\r\n *\r\n *  This interface is kept purposely un-opinionated to support a variety of storage types.\r\n *\r\n *  # Generics\r\n *  The interface requires two generics types be provided,\r\n *\r\n *  ### Q extends Cloneable\r\n *  This is the query type for the storage. In a typical key-value storage this is often a string key type, but\r\n *  in a more complex storage implementation, for instance indexedDb, this could be a query object.\r\n *  ### D extends Cloneable\r\n *  This represents the type of data being stored.\r\n *\r\n *  # Cloneable\r\n *  The IStorage interface does not allow any data or query types, they must extend the Cloneable interface.\r\n *  This is because the data must be able to be serialized, both for remote storages, and for storages that live in\r\n *  the inner smartedit application, as this data is passed over the w3c postMessage() between frames.\r\n */\r\nexport interface IStorage<Q extends Cloneable, D extends Cloneable> {\r\n    /**\r\n     * Get a data record from the storage.\r\n     *\r\n     * @param queryObject - The query type. In a key-value storage this would be the key\r\n     */\r\n    get: (queryObject?: Q) => Promise<D>;\r\n    /**\r\n     * Put a data record into the storage, or replace an existing record\r\n     *\r\n     * @param obj The data to store.\r\n     * @param queryObject The query object. In a key-value storage this would be the key\r\n     */\r\n    put: (obj: D, queryObject?: Q) => Promise<boolean>;\r\n    /**\r\n     * Remove a data record from the storage.\r\n     *\r\n     * @param queryObject The query object. In a key-value storage this would be the key\r\n     */\r\n    remove: (queryObject?: Q) => Promise<D>;\r\n    /**\r\n     * Find multiple records of data in the storage.\r\n     *\r\n     * @param queryObject The query type. In a key-value storage this would be the key\r\n     */\r\n    find: (queryObject?: Q) => Promise<D[]>;\r\n    /**\r\n     * Remove all data records from the storage.\r\n     */\r\n    clear: () => Promise<boolean>;\r\n    /**\r\n     * Get the number of data records in the storage\r\n     */\r\n    getLength: () => Promise<number>;\r\n    /**\r\n     * Remove all storage records and remove the storage itself and all metadata from the storage manager.\r\n     */\r\n    dispose: () => Promise<boolean>;\r\n    /**\r\n     * Get all query/data entries from the storage.\r\n     *\r\n     * For key-value storages this will be an array of key-value 2-tuples.\r\n     *\r\n     * ```[key, value][]```\r\n     */\r\n    entries: () => Promise<any[]>;\r\n}\r\n"}}
