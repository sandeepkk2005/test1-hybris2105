{"code":"import { __extends } from \"tslib\";\r\n/*\r\n * Abstract Class to create Custom Web Elements aimed at triggering some legacy AngularJS compilation\r\n * this class takes care of the following boilerplate:\r\n * - preventing enless recompilation due to AngularJS compilation modifying DOM hence retriggering custom web element processing.\r\n * - destroying the scope upon disconnection\r\n * - checking necessary conditions before triggering native custom element callbacks\r\n */\r\nvar AbstractAngularJSBasedCustomElement = /** @class */ (function (_super) {\r\n    __extends(AbstractAngularJSBasedCustomElement, _super);\r\n    function AbstractAngularJSBasedCustomElement(upgrade) {\r\n        var _this = _super.call(this) || this;\r\n        _this.upgrade = upgrade;\r\n        _this.PROCESSED_ATTRIBUTE_NAME = 'processed';\r\n        return _this;\r\n    }\r\n    // we need to protect against a stack overflow: custom elements -> $compile -> custom elements\r\n    AbstractAngularJSBasedCustomElement.prototype.markAsProcessed = function () {\r\n        this.setAttribute(this.PROCESSED_ATTRIBUTE_NAME, 'true');\r\n    };\r\n    AbstractAngularJSBasedCustomElement.prototype.connectedCallback = function () {\r\n        if (!this.isConnected || this.getAttribute(this.PROCESSED_ATTRIBUTE_NAME)) {\r\n            return;\r\n        }\r\n        this.internalConnectedCallback();\r\n    };\r\n    AbstractAngularJSBasedCustomElement.prototype.disconnectedCallback = function () {\r\n        if (!this.scope || this.isConnected) {\r\n            return;\r\n        }\r\n        this.scope.$destroy();\r\n        this.internalDisconnectedCallback && this.internalDisconnectedCallback();\r\n    };\r\n    AbstractAngularJSBasedCustomElement.prototype.attributeChangedCallback = function (name, oldValue, newValue) {\r\n        /*\r\n         * attributes don't change in the case of decorators:\r\n         * - they come from the shallow clone itself\r\n         * - only active flag changes but because of the full rewrapping it goes through constructor\r\n         */\r\n        if (!this.shouldReactOnAttributeChange()) {\r\n            return;\r\n        }\r\n        this.internalAttributeChangedCallback(name, oldValue, newValue);\r\n    };\r\n    AbstractAngularJSBasedCustomElement.prototype.shouldReactOnAttributeChange = function () {\r\n        return (this.internalAttributeChangedCallback &&\r\n            this.scope &&\r\n            this.isConnected &&\r\n            !!this.getAttribute(this.PROCESSED_ATTRIBUTE_NAME));\r\n    };\r\n    Object.defineProperty(AbstractAngularJSBasedCustomElement.prototype, \"$rootScope\", {\r\n        get: function () {\r\n            return this.upgrade.injector.get('$rootScope');\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AbstractAngularJSBasedCustomElement.prototype, \"$compile\", {\r\n        get: function () {\r\n            return this.upgrade.injector.get('$compile');\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    return AbstractAngularJSBasedCustomElement;\r\n}(HTMLElement));\r\nexport { AbstractAngularJSBasedCustomElement };\r\n//# sourceMappingURL=ICustomElement.js.map","references":["/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedittools/common/temp/node_modules/.pnpm/@angular/upgrade@8.2.14_d2ff5303d1bb22207cb4aaa9bb380a83/node_modules/@angular/upgrade/static.d.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedittools/common/temp/node_modules/.pnpm/@types/angular@1.7.3/node_modules/@types/angular/index.d.ts"],"map":"{\"version\":3,\"file\":\"ICustomElement.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/utils/ICustomElement.ts\"],\"names\":[],\"mappings\":\";AAcA;;;;;;GAMG;AACH;IACY,uDAAW;IAenB,6CAAoB,OAAsB;QAA1C,YACI,iBAAO,SACV;QAFmB,aAAO,GAAP,OAAO,CAAe;QAXlC,8BAAwB,GAAG,WAAW,CAAC;;IAa/C,CAAC;IAMD,8FAA8F;IAC9F,6DAAe,GAAf;QACI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,wBAAwB,EAAE,MAAM,CAAC,CAAC;IAC7D,CAAC;IAED,+DAAiB,GAAjB;QACI,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,EAAE;YACvE,OAAO;SACV;QACD,IAAI,CAAC,yBAAyB,EAAE,CAAC;IACrC,CAAC;IAED,kEAAoB,GAApB;QACI,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,WAAW,EAAE;YACjC,OAAO;SACV;QACD,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;QACtB,IAAI,CAAC,4BAA4B,IAAI,IAAI,CAAC,4BAA4B,EAAE,CAAC;IAC7E,CAAC;IAED,sEAAwB,GAAxB,UAAyB,IAAY,EAAE,QAAa,EAAE,QAAa;QAC/D;;;;WAIG;QACH,IAAI,CAAC,IAAI,CAAC,4BAA4B,EAAE,EAAE;YACtC,OAAO;SACV;QACD,IAAI,CAAC,gCAAgC,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;IACpE,CAAC;IAEO,0EAA4B,GAApC;QACI,OAAO,CACH,IAAI,CAAC,gCAAgC;YACrC,IAAI,CAAC,KAAK;YACV,IAAI,CAAC,WAAW;YAChB,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,wBAAwB,CAAC,CACrD,CAAC;IACN,CAAC;IAED,sBAAI,2DAAU;aAAd;YACI,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QACnD,CAAC;;;OAAA;IAED,sBAAI,yDAAQ;aAAZ;YACI,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QACjD,CAAC;;;OAAA;IACL,0CAAC;AAAD,CAAC,AAxED,CACY,WAAW,GAuEtB\"}","dts":{"name":"/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/utils/ICustomElement.d.ts","writeByteOrderMark":false,"text":"import { UpgradeModule } from '@angular/upgrade/static';\r\nimport * as angular from 'angular';\r\nexport interface ICustomElement {\r\n    connectedCallback?(): void;\r\n    disconnectedCallback?(): void;\r\n    attributeChangedCallback?(name: string, oldValue: any, newValue: any): void;\r\n}\r\nexport declare type CustomElementConstructor = new (...arg: any[]) => ICustomElement;\r\nexport declare abstract class AbstractAngularJSBasedCustomElement extends HTMLElement implements ICustomElement {\r\n    private upgrade;\r\n    protected scope: angular.IScope;\r\n    private PROCESSED_ATTRIBUTE_NAME;\r\n    abstract internalConnectedCallback(): void;\r\n    constructor(upgrade: UpgradeModule);\r\n    internalAttributeChangedCallback?(name: string, oldValue: any, newValue: any): void;\r\n    internalDisconnectedCallback?(): void;\r\n    markAsProcessed(): void;\r\n    connectedCallback(): void;\r\n    disconnectedCallback(): void;\r\n    attributeChangedCallback(name: string, oldValue: any, newValue: any): void;\r\n    private shouldReactOnAttributeChange;\r\n    get $rootScope(): angular.IRootScopeService;\r\n    get $compile(): angular.ICompileService;\r\n}\r\n"}}
