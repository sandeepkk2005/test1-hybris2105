{"code":"import { __assign, __extends } from \"tslib\";\r\n/*\r\n * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.\r\n */\r\n/**\r\n * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.\r\n * @module smartutils\r\n */\r\nimport { FormGroup } from '@angular/forms';\r\nimport { InputProperties } from './input-properties';\r\nimport { ValidatorParameters } from './validator-parameters';\r\n/**\r\n * A FormGrouping is used to encapsulate form data\r\n * of objects.\r\n */\r\nvar FormGrouping = /** @class */ (function (_super) {\r\n    __extends(FormGrouping, _super);\r\n    function FormGrouping(controls, validatorOrOpts, _a) {\r\n        if (validatorOrOpts === void 0) { validatorOrOpts = {}; }\r\n        var component = _a.component, _b = _a.inputs, inputs = _b === void 0 ? new InputProperties() : _b, _c = _a.validatorParams, validatorParams = _c === void 0 ? new ValidatorParameters() : _c, _d = _a.persist, persist = _d === void 0 ? true : _d;\r\n        var _this = _super.call(this, controls, validatorOrOpts) || this;\r\n        _this.component = component;\r\n        _this.inputs = inputs;\r\n        _this.inputChanges = inputs.changes;\r\n        _this.validatorParams = validatorParams;\r\n        _this.persist = persist;\r\n        return _this;\r\n    }\r\n    /**\r\n     * @inheritdoc\r\n     * @param {keyof T} key\r\n     * @param {T[keyof T]} value\r\n     */\r\n    FormGrouping.prototype.setInput = function (key, value) {\r\n        this.inputs.set(key, value);\r\n    };\r\n    /**\r\n     * @inheritdoc\r\n     * @param {keyof T} key\r\n     * @returns {T[keyof T] | undefined}\r\n     */\r\n    FormGrouping.prototype.getInput = function (key) {\r\n        return this.inputs.get(key);\r\n    };\r\n    /**\r\n     * Manually sets nested errors to each FormControl.\r\n     *\r\n     * Note: Method should be called on the next rendering cycle and not on the initialization of the form. Should be\r\n     * used to enforce backend validation.\r\n     *\r\n     * @param errors\r\n     */\r\n    FormGrouping.prototype.setNestedErrors = function (errors) {\r\n        var _this = this;\r\n        if (errors === void 0) { errors = []; }\r\n        errors.forEach(function (_a) {\r\n            var path = _a[0], validationErrors = _a[1];\r\n            var form = _this.get(path);\r\n            /**\r\n             * Fail if the form does not exist.\r\n             */\r\n            if (!form) {\r\n                throw new Error(\"FormGrouping - Path not found when setting nested error: \" + path);\r\n            }\r\n            form.setErrors(validationErrors);\r\n        });\r\n    };\r\n    /**\r\n     * @inheritdoc\r\n     * @return any\r\n     */\r\n    FormGrouping.prototype.getPersistedValue = function () {\r\n        var _this = this;\r\n        return Object.keys(this.controls).reduce(function (acc, key) {\r\n            var child = _this.controls[key];\r\n            /**\r\n             * Look ahead and if nested does not want to be mapped, merge the nested object with\r\n             * the current object.\r\n             *\r\n             * If it's a field, then it's undefined.\r\n             *\r\n             * If it's a group, then it will be merged.\r\n             */\r\n            if (!child.persist) {\r\n                return __assign(__assign({}, acc), child.getPersistedValue());\r\n            }\r\n            acc[key] = child.getPersistedValue();\r\n            return acc;\r\n        }, {});\r\n    };\r\n    return FormGrouping;\r\n}(FormGroup));\r\nexport { FormGrouping };\r\n//# sourceMappingURL=form-grouping.js.map","references":["/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedittools/common/temp/node_modules/.pnpm/@angular/forms@8.2.14_e9fbe5720e9434eb9ae0f6720f1ca3f4/node_modules/@angular/forms/forms.d.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedittools/common/temp/node_modules/.pnpm/rxjs@6.5.4/node_modules/rxjs/index.d.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/src/modules/form-builder/models/abstract-form.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/src/modules/form-builder/models/input-properties.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/src/modules/form-builder/models/interfaces.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/src/modules/form-builder/models/validator-parameters.ts"],"map":"{\"version\":3,\"file\":\"form-grouping.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/modules/form-builder/models/form-grouping.ts\"],\"names\":[],\"mappings\":\";AAAA;;GAEG;AACH;;;GAGG;AACH,OAAO,EAGH,SAAS,EAEZ,MAAM,gBAAgB,CAAC;AAKxB,OAAO,EAAE,eAAe,EAAuB,MAAM,oBAAoB,CAAC;AAE1E,OAAO,EAAE,mBAAmB,EAAE,MAAM,wBAAwB,CAAC;AAE7D;;;GAGG;AACH;IAAkC,gCAAS;IAkCvC,sBACI,QAEC,EACD,eAA4C,EAC5C,EAUC;QAXD,gCAAA,EAAA,oBAA4C;YAExC,SAAS,eAAA,EACT,cAA8B,EAA9B,MAAM,mBAAG,IAAI,eAAe,EAAE,KAAA,EAC9B,uBAA2C,EAA3C,eAAe,mBAAG,IAAI,mBAAmB,EAAE,KAAA,EAC3C,eAAc,EAAd,OAAO,mBAAG,IAAI,KAAA;QATtB,YAiBI,kBAAM,QAAQ,EAAE,eAAe,CAAC,SAOnC;QALG,KAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,KAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,KAAI,CAAC,YAAY,GAAG,MAAM,CAAC,OAAO,CAAC;QACnC,KAAI,CAAC,eAAe,GAAG,eAAe,CAAC;QACvC,KAAI,CAAC,OAAO,GAAG,OAAO,CAAC;;IAC3B,CAAC;IAED;;;;OAIG;IACH,+BAAQ,GAAR,UAAY,GAAY,EAAE,KAAiB;QACvC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IAChC,CAAC;IAED;;;;OAIG;IACH,+BAAQ,GAAR,UAAY,GAAY;QACpB,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAI,GAAG,CAAC,CAAC;IACnC,CAAC;IAED;;;;;;;OAOG;IACH,sCAAe,GAAf,UAAgB,MAAoD;QAApE,iBAaC;QAbe,uBAAA,EAAA,WAAoD;QAChE,MAAM,CAAC,OAAO,CAAC,UAAC,EAAwB;gBAAvB,IAAI,QAAA,EAAE,gBAAgB,QAAA;YACnC,IAAM,IAAI,GAAG,KAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAE5B;;eAEG;YACH,IAAI,CAAC,IAAI,EAAE;gBACP,MAAM,IAAI,KAAK,CAAC,8DAA4D,IAAM,CAAC,CAAC;aACvF;YAED,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC;QACrC,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;OAGG;IACH,wCAAiB,GAAjB;QAAA,iBAmBC;QAlBG,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,GAAG;YAC9C,IAAM,KAAK,GAAG,KAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;YAEjC;;;;;;;eAOG;YACH,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;gBAChB,6BAAY,GAAG,GAAK,KAAK,CAAC,iBAAiB,EAAE,EAAG;aACnD;YAED,GAAG,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,iBAAiB,EAAE,CAAC;YACrC,OAAO,GAAG,CAAC;QACf,CAAC,EAAE,EAAS,CAAC,CAAC;IAClB,CAAC;IACL,mBAAC;AAAD,CAAC,AA7HD,CAAkC,SAAS,GA6H1C\"}","dts":{"name":"/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/modules/form-builder/models/form-grouping.d.ts","writeByteOrderMark":false,"text":"/**\r\n * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.\r\n * @module smartutils\r\n */\r\nimport { AbstractControl, AbstractControlOptions, FormGroup, ValidationErrors } from '@angular/forms';\r\nimport { Observable } from 'rxjs';\r\nimport { AbstractForm } from './abstract-form';\r\nimport { InputProperties, InputPropertyChange } from './input-properties';\r\nimport { ComponentType } from './interfaces';\r\nimport { ValidatorParameters } from './validator-parameters';\r\n/**\r\n * A FormGrouping is used to encapsulate form data\r\n * of objects.\r\n */\r\nexport declare class FormGrouping extends FormGroup implements AbstractForm {\r\n    /**\r\n     * @inheritdoc\r\n     * @override\r\n     */\r\n    readonly controls: {\r\n        [key: string]: AbstractForm;\r\n    };\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    readonly component: ComponentType;\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    readonly inputs: InputProperties;\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    readonly validatorParams: ValidatorParameters;\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    readonly persist: boolean;\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    readonly inputChanges: Observable<InputPropertyChange>;\r\n    constructor(controls: {\r\n        [key: string]: AbstractControl;\r\n    }, validatorOrOpts: AbstractControlOptions, { component, inputs, validatorParams, persist }: {\r\n        component: ComponentType;\r\n        inputs: InputProperties;\r\n        validatorParams: ValidatorParameters;\r\n        persist: boolean;\r\n    });\r\n    /**\r\n     * @inheritdoc\r\n     * @param {keyof T} key\r\n     * @param {T[keyof T]} value\r\n     */\r\n    setInput<T>(key: keyof T, value: T[keyof T]): void;\r\n    /**\r\n     * @inheritdoc\r\n     * @param {keyof T} key\r\n     * @returns {T[keyof T] | undefined}\r\n     */\r\n    getInput<T>(key: keyof T): T[keyof T] | undefined;\r\n    /**\r\n     * Manually sets nested errors to each FormControl.\r\n     *\r\n     * Note: Method should be called on the next rendering cycle and not on the initialization of the form. Should be\r\n     * used to enforce backend validation.\r\n     *\r\n     * @param errors\r\n     */\r\n    setNestedErrors(errors?: [string[] | string, ValidationErrors][]): void;\r\n    /**\r\n     * @inheritdoc\r\n     * @return any\r\n     */\r\n    getPersistedValue(): any;\r\n}\r\n"}}
