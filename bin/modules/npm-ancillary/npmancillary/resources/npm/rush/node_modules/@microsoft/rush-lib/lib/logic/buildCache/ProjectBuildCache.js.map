{"version":3,"file":"ProjectBuildCache.js","sourceRoot":"","sources":["../../../src/logic/buildCache/ProjectBuildCache.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as events from 'events';\r\nimport * as crypto from 'crypto';\r\nimport type * as stream from 'stream';\r\nimport * as tar from 'tar';\r\nimport { FileSystem, LegacyAdapters, Path, Terminal } from '@rushstack/node-core-library';\r\nimport * as fs from 'fs';\r\n\r\nimport { RushConfigurationProject } from '../../api/RushConfigurationProject';\r\nimport { PackageChangeAnalyzer } from '../PackageChangeAnalyzer';\r\nimport { RushProjectConfiguration } from '../../api/RushProjectConfiguration';\r\nimport { RushConstants } from '../RushConstants';\r\nimport { BuildCacheConfiguration } from '../../api/BuildCacheConfiguration';\r\nimport { CloudBuildCacheProviderBase } from './CloudBuildCacheProviderBase';\r\nimport { FileSystemBuildCacheProvider } from './FileSystemBuildCacheProvider';\r\nimport { TarExecutable } from '../../utilities/TarExecutable';\r\nimport { Utilities } from '../../utilities/Utilities';\r\n\r\ninterface IProjectBuildCacheOptions {\r\n  buildCacheConfiguration: BuildCacheConfiguration;\r\n  projectConfiguration: RushProjectConfiguration;\r\n  command: string;\r\n  trackedProjectFiles: string[] | undefined;\r\n  packageChangeAnalyzer: PackageChangeAnalyzer;\r\n  terminal: Terminal;\r\n}\r\n\r\ninterface IPathsToCache {\r\n  filteredOutputFolderNames: string[];\r\n  outputFilePaths: string[];\r\n}\r\n\r\nexport class ProjectBuildCache {\r\n  /**\r\n   * null === we haven't tried to initialize yet\r\n   * undefined === unable to initialize\r\n   */\r\n  private static _tarUtility: TarExecutable | null | undefined = null;\r\n\r\n  private readonly _project: RushConfigurationProject;\r\n  private readonly _localBuildCacheProvider: FileSystemBuildCacheProvider;\r\n  private readonly _cloudBuildCacheProvider: CloudBuildCacheProviderBase | undefined;\r\n  private readonly _projectOutputFolderNames: string[];\r\n  private readonly _cacheId: string | undefined;\r\n\r\n  private constructor(options: Omit<IProjectBuildCacheOptions, 'terminal'>) {\r\n    this._project = options.projectConfiguration.project;\r\n    this._localBuildCacheProvider = options.buildCacheConfiguration.localCacheProvider;\r\n    this._cloudBuildCacheProvider = options.buildCacheConfiguration.cloudCacheProvider;\r\n    this._projectOutputFolderNames = options.projectConfiguration.projectOutputFolderNames || [];\r\n    this._cacheId = ProjectBuildCache._getCacheId(options);\r\n  }\r\n\r\n  private static _tryGetTarUtility(terminal: Terminal): TarExecutable | undefined {\r\n    if (ProjectBuildCache._tarUtility === null) {\r\n      ProjectBuildCache._tarUtility = TarExecutable.tryInitialize(terminal);\r\n    }\r\n\r\n    return ProjectBuildCache._tarUtility;\r\n  }\r\n\r\n  public static tryGetProjectBuildCache(options: IProjectBuildCacheOptions): ProjectBuildCache | undefined {\r\n    const { terminal, projectConfiguration, trackedProjectFiles } = options;\r\n    if (!trackedProjectFiles) {\r\n      return undefined;\r\n    }\r\n\r\n    if (!ProjectBuildCache._validateProject(terminal, projectConfiguration, trackedProjectFiles)) {\r\n      return undefined;\r\n    }\r\n\r\n    return new ProjectBuildCache(options);\r\n  }\r\n\r\n  private static _validateProject(\r\n    terminal: Terminal,\r\n    projectConfiguration: RushProjectConfiguration,\r\n    trackedProjectFiles: string[]\r\n  ): boolean {\r\n    const normalizedProjectRelativeFolder: string = Path.convertToSlashes(\r\n      projectConfiguration.project.projectRelativeFolder\r\n    );\r\n    const outputFolders: string[] = [];\r\n    if (projectConfiguration.projectOutputFolderNames) {\r\n      for (const outputFolderName of projectConfiguration.projectOutputFolderNames) {\r\n        outputFolders.push(`${normalizedProjectRelativeFolder}/${outputFolderName}/`);\r\n      }\r\n    }\r\n\r\n    const inputOutputFiles: string[] = [];\r\n    for (const file of trackedProjectFiles) {\r\n      for (const outputFolder of outputFolders) {\r\n        if (file.startsWith(outputFolder)) {\r\n          inputOutputFiles.push(file);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (inputOutputFiles.length > 0) {\r\n      terminal.writeWarningLine(\r\n        'Unable to use build cache. The following files are used to calculate project state ' +\r\n          `and are considered project output: ${inputOutputFiles.join(', ')}`\r\n      );\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  public async tryRestoreFromCacheAsync(terminal: Terminal): Promise<boolean> {\r\n    const cacheId: string | undefined = this._cacheId;\r\n    if (!cacheId) {\r\n      terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');\r\n      return false;\r\n    }\r\n\r\n    let localCacheEntryPath:\r\n      | string\r\n      | undefined = await this._localBuildCacheProvider.tryGetCacheEntryPathByIdAsync(terminal, cacheId);\r\n    let cacheEntryBuffer: Buffer | undefined;\r\n    let updateLocalCacheSuccess: boolean | undefined;\r\n    if (!localCacheEntryPath && this._cloudBuildCacheProvider) {\r\n      terminal.writeVerboseLine(\r\n        'This project was not found in the local build cache. Querying the cloud build cache.'\r\n      );\r\n\r\n      cacheEntryBuffer = await this._cloudBuildCacheProvider.tryGetCacheEntryBufferByIdAsync(\r\n        terminal,\r\n        cacheId\r\n      );\r\n      if (cacheEntryBuffer) {\r\n        try {\r\n          localCacheEntryPath = await this._localBuildCacheProvider.trySetCacheEntryBufferAsync(\r\n            terminal,\r\n            cacheId,\r\n            cacheEntryBuffer\r\n          );\r\n          updateLocalCacheSuccess = true;\r\n        } catch (e) {\r\n          updateLocalCacheSuccess = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!localCacheEntryPath && !cacheEntryBuffer) {\r\n      terminal.writeVerboseLine('This project was not found in the build cache.');\r\n      return false;\r\n    }\r\n\r\n    terminal.writeLine('Build cache hit.');\r\n\r\n    const projectFolderPath: string = this._project.projectFolder;\r\n\r\n    // Purge output folders\r\n    terminal.writeVerboseLine(`Clearing cached folders: ${this._projectOutputFolderNames.join(', ')}`);\r\n    await Promise.all(\r\n      this._projectOutputFolderNames.map((outputFolderName: string) =>\r\n        FileSystem.deleteFolderAsync(`${projectFolderPath}/${outputFolderName}`)\r\n      )\r\n    );\r\n\r\n    const tarUtility: TarExecutable | undefined = ProjectBuildCache._tryGetTarUtility(terminal);\r\n    let restoreSuccess: boolean = false;\r\n    if (tarUtility && localCacheEntryPath) {\r\n      const tarExitCode: number = await tarUtility.tryUntarAsync(localCacheEntryPath, projectFolderPath);\r\n      if (tarExitCode === 0) {\r\n        restoreSuccess = true;\r\n      } else {\r\n        terminal.writeWarningLine(\r\n          `\"tar\" exited with code ${tarExitCode} while attempting to restore cache entry. ` +\r\n            'Rush will attempt to extract from the cache entry with a JavaScript implementation of tar.'\r\n        );\r\n      }\r\n    }\r\n\r\n    if (!restoreSuccess) {\r\n      if (!cacheEntryBuffer && localCacheEntryPath) {\r\n        cacheEntryBuffer = await FileSystem.readFileToBufferAsync(localCacheEntryPath);\r\n      }\r\n\r\n      if (!cacheEntryBuffer) {\r\n        throw new Error('Expected the cache entry buffer to be set.');\r\n      }\r\n\r\n      // If we don't have tar on the PATH, if we failed to update the local cache entry,\r\n      // or if the tar binary failed, untar in-memory\r\n      const tarStream: stream.Writable = tar.extract({ cwd: projectFolderPath });\r\n      try {\r\n        const tarPromise: Promise<unknown> = events.once(tarStream, 'drain');\r\n        tarStream.write(cacheEntryBuffer);\r\n        await tarPromise;\r\n        restoreSuccess = true;\r\n      } catch (e) {\r\n        restoreSuccess = false;\r\n      }\r\n    }\r\n\r\n    if (restoreSuccess) {\r\n      terminal.writeLine('Successfully restored output from the build cache.');\r\n    } else {\r\n      terminal.writeWarningLine('Unable to restore output from the build cache.');\r\n    }\r\n\r\n    if (updateLocalCacheSuccess === false) {\r\n      terminal.writeWarningLine('Unable to update the local build cache with data from the cloud cache.');\r\n    }\r\n\r\n    return restoreSuccess;\r\n  }\r\n\r\n  public async trySetCacheEntryAsync(terminal: Terminal): Promise<boolean> {\r\n    const cacheId: string | undefined = this._cacheId;\r\n    if (!cacheId) {\r\n      terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');\r\n      return false;\r\n    }\r\n\r\n    const projectFolderPath: string = this._project.projectFolder;\r\n    const filesToCache: IPathsToCache | undefined = await this._tryCollectPathsToCacheAsync(terminal);\r\n    if (!filesToCache) {\r\n      return false;\r\n    }\r\n\r\n    terminal.writeVerboseLine(\r\n      `Caching build output folders: ${filesToCache.filteredOutputFolderNames.join(', ')}`\r\n    );\r\n\r\n    let localCacheEntryPath: string | undefined;\r\n\r\n    const tarUtility: TarExecutable | undefined = ProjectBuildCache._tryGetTarUtility(terminal);\r\n    if (tarUtility) {\r\n      const tempLocalCacheEntryPath: string = this._localBuildCacheProvider.getCacheEntryPath(cacheId);\r\n      const tarExitCode: number = await tarUtility.tryCreateArchiveFromProjectPathsAsync(\r\n        tempLocalCacheEntryPath,\r\n        filesToCache.outputFilePaths,\r\n        this._project\r\n      );\r\n      if (tarExitCode === 0) {\r\n        localCacheEntryPath = tempLocalCacheEntryPath;\r\n      } else {\r\n        terminal.writeWarningLine(\r\n          `\"tar\" exited with code ${tarExitCode} while attempting to create the cache entry. ` +\r\n            'Rush will attempt to create the cache entry with a JavaScript implementation of tar.'\r\n        );\r\n      }\r\n    }\r\n\r\n    let cacheEntryBuffer: Buffer | undefined;\r\n    let setLocalCacheEntryPromise: Promise<string> | undefined;\r\n    if (!localCacheEntryPath) {\r\n      // If we weren't able to create the cache entry with tar, try to do it with the \"tar\" NPM package\r\n      const tarStream: stream.Readable = tar.create(\r\n        {\r\n          gzip: true,\r\n          portable: true,\r\n          strict: true,\r\n          cwd: projectFolderPath\r\n        },\r\n        filesToCache.outputFilePaths\r\n      );\r\n      cacheEntryBuffer = await Utilities.readStreamToBufferAsync(tarStream);\r\n      setLocalCacheEntryPromise = this._localBuildCacheProvider.trySetCacheEntryBufferAsync(\r\n        terminal,\r\n        cacheId,\r\n        cacheEntryBuffer\r\n      );\r\n    } else {\r\n      setLocalCacheEntryPromise = Promise.resolve(localCacheEntryPath);\r\n    }\r\n\r\n    let setCloudCacheEntryPromise: Promise<boolean> | undefined;\r\n    if (this._cloudBuildCacheProvider?.isCacheWriteAllowed === true) {\r\n      if (!cacheEntryBuffer) {\r\n        if (localCacheEntryPath) {\r\n          cacheEntryBuffer = await FileSystem.readFileToBufferAsync(localCacheEntryPath);\r\n        } else {\r\n          throw new Error('Expected the local cache entry path to be set.');\r\n        }\r\n      }\r\n\r\n      setCloudCacheEntryPromise = this._cloudBuildCacheProvider.trySetCacheEntryBufferAsync(\r\n        terminal,\r\n        cacheId,\r\n        cacheEntryBuffer\r\n      );\r\n    }\r\n\r\n    let localCachePath: string;\r\n    let updateCloudCacheSuccess: boolean;\r\n    if (setCloudCacheEntryPromise) {\r\n      [updateCloudCacheSuccess, localCachePath] = await Promise.all([\r\n        setCloudCacheEntryPromise,\r\n        setLocalCacheEntryPromise\r\n      ]);\r\n    } else {\r\n      updateCloudCacheSuccess = true;\r\n      localCachePath = await setLocalCacheEntryPromise;\r\n    }\r\n\r\n    const success: boolean = updateCloudCacheSuccess && !!localCachePath;\r\n    if (success) {\r\n      terminal.writeLine('Successfully set cache entry.');\r\n    } else if (!localCachePath && updateCloudCacheSuccess) {\r\n      terminal.writeWarningLine('Unable to set local cache entry.');\r\n    } else if (localCachePath && !updateCloudCacheSuccess) {\r\n      terminal.writeWarningLine('Unable to set cloud cache entry.');\r\n    } else {\r\n      terminal.writeWarningLine('Unable to set both cloud and local cache entries.');\r\n    }\r\n\r\n    return success;\r\n  }\r\n\r\n  private async _tryCollectPathsToCacheAsync(terminal: Terminal): Promise<IPathsToCache | undefined> {\r\n    const projectFolderPath: string = this._project.projectFolder;\r\n    const outputFolderNamesThatExist: boolean[] = await Promise.all(\r\n      this._projectOutputFolderNames.map((outputFolderName) =>\r\n        FileSystem.existsAsync(`${projectFolderPath}/${outputFolderName}`)\r\n      )\r\n    );\r\n    const filteredOutputFolderNames: string[] = [];\r\n    for (let i: number = 0; i < outputFolderNamesThatExist.length; i++) {\r\n      if (outputFolderNamesThatExist[i]) {\r\n        filteredOutputFolderNames.push(this._projectOutputFolderNames[i]);\r\n      }\r\n    }\r\n\r\n    let encounteredEnumerationIssue: boolean = false;\r\n    function symbolicLinkPathCallback(entryPath: string): void {\r\n      terminal.writeError(`Unable to include \"${entryPath}\" in build cache. It is a symbolic link.`);\r\n      encounteredEnumerationIssue = true;\r\n    }\r\n\r\n    const outputFilePaths: string[] = [];\r\n    for (const filteredOutputFolderName of filteredOutputFolderNames) {\r\n      if (encounteredEnumerationIssue) {\r\n        return undefined;\r\n      }\r\n\r\n      const outputFilePathsForFolder: AsyncIterableIterator<string> = this._getPathsInFolder(\r\n        terminal,\r\n        symbolicLinkPathCallback,\r\n        filteredOutputFolderName,\r\n        `${projectFolderPath}/${filteredOutputFolderName}`\r\n      );\r\n\r\n      for await (const outputFilePath of outputFilePathsForFolder) {\r\n        outputFilePaths.push(outputFilePath);\r\n      }\r\n    }\r\n\r\n    if (encounteredEnumerationIssue) {\r\n      return undefined;\r\n    }\r\n\r\n    return {\r\n      filteredOutputFolderNames,\r\n      outputFilePaths\r\n    };\r\n  }\r\n\r\n  private async *_getPathsInFolder(\r\n    terminal: Terminal,\r\n    symbolicLinkPathCallback: (path: string) => void,\r\n    posixPrefix: string,\r\n    folderPath: string\r\n  ): AsyncIterableIterator<string> {\r\n    const folderEntries: fs.Dirent[] = await LegacyAdapters.convertCallbackToPromise(fs.readdir, folderPath, {\r\n      withFileTypes: true\r\n    });\r\n    for (const folderEntry of folderEntries) {\r\n      const entryPath: string = `${posixPrefix}/${folderEntry.name}`;\r\n      if (folderEntry.isSymbolicLink()) {\r\n        symbolicLinkPathCallback(entryPath);\r\n      } else if (folderEntry.isDirectory()) {\r\n        yield* this._getPathsInFolder(\r\n          terminal,\r\n          symbolicLinkPathCallback,\r\n          entryPath,\r\n          `${folderPath}/${folderEntry.name}`\r\n        );\r\n      } else {\r\n        yield entryPath;\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _getCacheId(options: Omit<IProjectBuildCacheOptions, 'terminal'>): string | undefined {\r\n    // The project state hash is calculated in the following method:\r\n    // - The current project's hash (see PackageChangeAnalyzer.getProjectStateHash) is\r\n    //   calculated and appended to an array\r\n    // - The current project's recursive dependency projects' hashes are calculated\r\n    //   and appended to the array\r\n    // - A SHA1 hash is created and the following data is fed into it, in order:\r\n    //   1. The JSON-serialized list of output folder names for this\r\n    //      project (see ProjectBuildCache._projectOutputFolderNames)\r\n    //   2. The command that will be run in the project\r\n    //   3. Each dependency project hash (from the array constructed in previous steps),\r\n    //      in sorted alphanumerical-sorted order\r\n    // - A hex digest of the hash is returned\r\n    const packageChangeAnalyzer: PackageChangeAnalyzer = options.packageChangeAnalyzer;\r\n    const projectStates: string[] = [];\r\n    const projectsThatHaveBeenProcessed: Set<RushConfigurationProject> = new Set<RushConfigurationProject>();\r\n    let projectsToProcess: Set<RushConfigurationProject> = new Set<RushConfigurationProject>();\r\n    projectsToProcess.add(options.projectConfiguration.project);\r\n\r\n    while (projectsToProcess.size > 0) {\r\n      const newProjectsToProcess: Set<RushConfigurationProject> = new Set<RushConfigurationProject>();\r\n      for (const projectToProcess of projectsToProcess) {\r\n        projectsThatHaveBeenProcessed.add(projectToProcess);\r\n\r\n        const projectState: string | undefined = packageChangeAnalyzer.getProjectStateHash(\r\n          projectToProcess.packageName\r\n        );\r\n        if (!projectState) {\r\n          // If we hit any projects with unknown state, return unknown cache ID\r\n          return undefined;\r\n        } else {\r\n          projectStates.push(projectState);\r\n          for (const dependency of projectToProcess.dependencyProjects) {\r\n            if (!projectsThatHaveBeenProcessed.has(dependency)) {\r\n              newProjectsToProcess.add(dependency);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      projectsToProcess = newProjectsToProcess;\r\n    }\r\n\r\n    const sortedProjectStates: string[] = projectStates.sort();\r\n    const hash: crypto.Hash = crypto.createHash('sha1');\r\n    const serializedOutputFolders: string = JSON.stringify(\r\n      options.projectConfiguration.projectOutputFolderNames\r\n    );\r\n    hash.update(serializedOutputFolders);\r\n    hash.update(RushConstants.hashDelimiter);\r\n    hash.update(options.command);\r\n    hash.update(RushConstants.hashDelimiter);\r\n    for (const projectHash of sortedProjectStates) {\r\n      hash.update(projectHash);\r\n      hash.update(RushConstants.hashDelimiter);\r\n    }\r\n\r\n    const projectStateHash: string = hash.digest('hex');\r\n\r\n    return options.buildCacheConfiguration.getCacheEntryId({\r\n      projectName: options.projectConfiguration.project.packageName,\r\n      projectStateHash\r\n    });\r\n  }\r\n}\r\n"]}