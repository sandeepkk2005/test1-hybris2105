"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PnpmProjectDependencyManifest = void 0;
const path = __importStar(require("path"));
const crypto_1 = __importDefault(require("crypto"));
const node_core_library_1 = require("@rushstack/node-core-library");
const RushConstants_1 = require("../RushConstants");
/**
 * This class handles creating the project/.rush/temp/shrinkwrap-deps.json file
 * which tracks the direct and indirect dependencies that a project consumes. This is used
 * to better determine which projects should be rebuilt when dependencies are updated.
 */
class PnpmProjectDependencyManifest {
    constructor(options) {
        this._pnpmShrinkwrapFile = options.pnpmShrinkwrapFile;
        this._project = options.project;
        this._projectDependencyManifestFilename = PnpmProjectDependencyManifest.getFilePathForProject(this._project);
        this._projectDependencyManifestFile = new Map();
    }
    /**
     * Get the fully-qualified path to the project/.rush/temp/shrinkwrap-deps.json
     * for the specified project.
     */
    static getFilePathForProject(project) {
        return path.join(project.projectRushTempFolder, RushConstants_1.RushConstants.projectDependencyManifestFilename);
    }
    addDependency(name, version, parentShrinkwrapEntry) {
        this._addDependencyInternal(name, version, parentShrinkwrapEntry);
    }
    /**
     * Save the current state of the object to project/.rush/temp/shrinkwrap-deps.json
     */
    async saveAsync() {
        const file = {};
        const keys = Array.from(this._projectDependencyManifestFile.keys()).sort();
        for (const key of keys) {
            file[key] = this._projectDependencyManifestFile.get(key);
        }
        await node_core_library_1.JsonFile.saveAsync(file, this._projectDependencyManifestFilename, { ensureFolderExists: true });
    }
    /**
     * If the project/.rush/temp/shrinkwrap-deps.json file exists, delete it. Otherwise, do nothing.
     */
    deleteIfExistsAsync() {
        return node_core_library_1.FileSystem.deleteFileAsync(this._projectDependencyManifestFilename, { throwIfNotExists: false });
    }
    _addDependencyInternal(name, version, parentShrinkwrapEntry, throwIfShrinkwrapEntryMissing = true) {
        const shrinkwrapEntry = this._pnpmShrinkwrapFile.getShrinkwrapEntry(name, version);
        if (!shrinkwrapEntry) {
            if (throwIfShrinkwrapEntryMissing) {
                throw new node_core_library_1.InternalError(`Unable to find dependency ${name} with version ${version} in shrinkwrap.`);
            }
            return;
        }
        const specifier = `${name}@${version}`;
        let integrity = shrinkwrapEntry.resolution.integrity;
        if (!integrity) {
            // git dependency specifiers do not have an integrity entry
            // Example ('integrity' doesn't exist in 'resolution'):
            //
            // github.com/chfritz/node-xmlrpc/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38:
            //   dependencies:
            //     sax: 1.2.4
            //     xmlbuilder: 8.2.2
            //   dev: false
            //   engines:
            //     node: '>=0.8'
            //     npm: '>=1.0.0'
            //   name: xmlrpc
            //   resolution:
            //     tarball: 'https://codeload.github.com/chfritz/node-xmlrpc/tar.gz/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38'
            //   version: 1.3.2
            const sha256Digest = crypto_1.default
                .createHash('sha256')
                .update(JSON.stringify(shrinkwrapEntry))
                .digest('hex');
            integrity = `${name}@${version}:${sha256Digest}:`;
        }
        if (this._projectDependencyManifestFile.has(specifier)) {
            if (this._projectDependencyManifestFile.get(specifier) !== integrity) {
                throw new Error(`Collision: ${specifier} already exists in with a different integrity`);
            }
            return;
        }
        // Add the current dependency
        this._projectDependencyManifestFile.set(specifier, integrity);
        // Add the dependencies of the dependency
        for (const dependencyName in shrinkwrapEntry.dependencies) {
            if (shrinkwrapEntry.dependencies.hasOwnProperty(dependencyName)) {
                const dependencyVersion = shrinkwrapEntry.dependencies[dependencyName];
                this._addDependencyInternal(dependencyName, dependencyVersion, shrinkwrapEntry);
            }
        }
        // Add the optional dependencies of the dependency
        for (const optionalDependencyName in shrinkwrapEntry.optionalDependencies) {
            if (shrinkwrapEntry.optionalDependencies.hasOwnProperty(optionalDependencyName)) {
                // Optional dependencies may not exist. Don't blow up if it can't be found
                const dependencyVersion = shrinkwrapEntry.optionalDependencies[optionalDependencyName];
                this._addDependencyInternal(optionalDependencyName, dependencyVersion, shrinkwrapEntry, (throwIfShrinkwrapEntryMissing = false));
            }
        }
        // When using workspaces, hoisting of peer dependencies to a singular top-level project is not possible.
        // Therefore, all packages that are consumed should be specified in the dependency tree. Given this, there
        // is no need to look for peer dependencies, since it is simply a constraint to be validated by the
        // package manager. Also return if we have no peer dependencies to scavenge through.
        if ((this._project.rushConfiguration.pnpmOptions &&
            this._project.rushConfiguration.pnpmOptions.useWorkspaces) ||
            !shrinkwrapEntry.peerDependencies) {
            return;
        }
        for (const peerDependencyName of Object.keys(shrinkwrapEntry.peerDependencies)) {
            // Check to see if the peer dependency is satisfied with the current shrinkwrap
            // entry. If not, check the parent shrinkwrap entry. Finally, if neither have
            // the specified dependency, check that the parent mentions the dependency in
            // it's own peer dependencies. If it is, we can rely on the package manager and
            // make the assumption that we've already found it further up the stack.
            if ((shrinkwrapEntry.dependencies && shrinkwrapEntry.dependencies.hasOwnProperty(peerDependencyName)) ||
                (parentShrinkwrapEntry.dependencies &&
                    parentShrinkwrapEntry.dependencies.hasOwnProperty(peerDependencyName)) ||
                (parentShrinkwrapEntry.peerDependencies &&
                    parentShrinkwrapEntry.peerDependencies.hasOwnProperty(peerDependencyName))) {
                continue;
            }
            // As a last attempt, check if it's been hoisted up as a top-level dependency. If
            // we can't find it, we can assume that it's already been provided somewhere up the
            // dependency tree.
            const topLevelDependencySpecifier = this._pnpmShrinkwrapFile.getTopLevelDependencyVersion(peerDependencyName);
            if (topLevelDependencySpecifier) {
                this._addDependencyInternal(peerDependencyName, this._pnpmShrinkwrapFile.getTopLevelDependencyKey(peerDependencyName), shrinkwrapEntry);
            }
        }
    }
}
exports.PnpmProjectDependencyManifest = PnpmProjectDependencyManifest;
//# sourceMappingURL=PnpmProjectDependencyManifest.js.map