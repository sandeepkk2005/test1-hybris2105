{"code":"var prepareRuleConfiguration = function (ruleConfiguration) {\r\n    this.ruleVerifyFunctions = this.ruleVerifyFunctions || {};\r\n    this.ruleVerifyFunctions[ruleConfiguration.names.join('-')] = {\r\n        verify: ruleConfiguration.verify\r\n    };\r\n    delete ruleConfiguration.verify;\r\n    return ruleConfiguration;\r\n};\r\nvar validateRule = function (rule) {\r\n    if (!(rule.names instanceof Array)) {\r\n        throw Error('Rule names must be array');\r\n    }\r\n    if (rule.names.length < 1) {\r\n        throw Error('Rule requires at least one name');\r\n    }\r\n    if (!rule.verify) {\r\n        throw Error('Rule requires a verify function');\r\n    }\r\n    if (typeof rule.verify !== 'function') {\r\n        throw Error('Rule verify must be a function');\r\n    }\r\n};\r\n/**\r\n * The permission service is used to check if a user has been granted certain permissions.\r\n *\r\n * It is configured with rules and permissions. A rule is used to execute some logic to determine whether or not\r\n * the permission should be granted. A permission references a list of rules. In order for a permission to be\r\n * granted, each rule must be executed successfully and return true.\r\n */\r\nvar IPermissionService = /** @class */ (function () {\r\n    function IPermissionService() {\r\n    }\r\n    /**\r\n     * This method clears all cached results in the rules' caches.\r\n     */\r\n    IPermissionService.prototype.clearCache = function () {\r\n        'proxyFunction';\r\n        return;\r\n    };\r\n    /**\r\n     * This method returns the registered permission that contains the given name in its\r\n     * array of names.\r\n     *\r\n     * @returns The permission with the given name, undefined otherwise.\r\n     */\r\n    IPermissionService.prototype.getPermission = function (permission) {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    /**\r\n     * This method checks if a user has been granted certain permissions.\r\n     *\r\n     * It takes an array of permission objects structured as follows:\r\n     *\r\n     * ### Example\r\n     *\r\n     *      {\r\n     *          names: [\"permission.aliases\"],\r\n     *          context: {\r\n     *              data: \"required to check a permission\"\r\n     *          }\r\n     *      }\r\n     *\r\n     *\r\n     * @returns A promise that resolves to true if permission is granted, rejects to false if it isn't and rejects on error.\r\n     */\r\n    IPermissionService.prototype.isPermitted = function (permissions) {\r\n        'proxyFunction';\r\n        return null;\r\n    };\r\n    /**\r\n     * This method registers a permission.\r\n     *\r\n     * A permission is defined by a set of aliases and rules. It is verified by its set of rules.\r\n     * The set of aliases is there for convenience, as there may be different permissions\r\n     * that use the same set of rules to be verified. The permission aliases property\r\n     * will resolve if any one alias is in the aliases' array. Calling [isPermitted]{@link IPermissionService#isPermitted}\r\n     * with any of these aliases will use the same permission object, therefore the same\r\n     * combination of rules to check if the user has the appropriate clearance. This reduces the\r\n     * number of permissions you need to register.\r\n     *\r\n     * ### Throws\r\n     *\r\n     * - Will throw an error if the permission has no aliases array\r\n     * - Will throw an error if the permission's aliases array is empty\r\n     * - Will throw an error if the permission has no rules array\r\n     * - Will throw an error if the permission's rule aliases array is empty\r\n     * - Will throw an error if a permission is already registered with a common entry in its array of aliases\r\n     * - Will throw an error if one of the permission's aliases is not name spaced\r\n     * - Will throw an error if no rule is registered with on of the permission's rule names\r\n     */\r\n    IPermissionService.prototype.registerPermission = function (permission) {\r\n        'proxyFunction';\r\n        return;\r\n    };\r\n    /**\r\n     * This method registers a rule. These rules can be used by registering permissions that\r\n     * use them to verify if a user has the appropriate clearance.\r\n     *\r\n     * To avoid accidentally overriding the default rule, an error is thrown when attempting\r\n     * to register a rule with the {@link /smarteditcontainer/miscellaneous/variables.html#DEFAULT_DEFAULT_RULE_NAME default rule name}.\r\n     *\r\n     * To register the default rule, see [registerDefaultRule]{@link IPermissionService#registerDefaultRule}.\r\n     *\r\n     * It must return a promise that responds with true, false, or an error.\r\n     *\r\n     * ### Throws\r\n     *\r\n     * - Will throw an error if the list of rule names contains the reserved {@link /smarteditcontainer/miscellaneous/variables.html#DEFAULT_DEFAULT_RULE_NAME default rule name}.\r\n     * - Will throw an error if the rule has no names array.\r\n     * - Will throw an error if the rule's names array is empty.\r\n     * - Will throw an error if the rule has no verify function.\r\n     * - Will throw an error if the rule's verify parameter is not a function.\r\n     * - Will throw an error if a rule is already registered with a common entry in its names array\r\n     */\r\n    IPermissionService.prototype.registerRule = function (ruleConfiguration) {\r\n        validateRule(ruleConfiguration);\r\n        ruleConfiguration = prepareRuleConfiguration.bind(this)(ruleConfiguration);\r\n        this._registerRule(ruleConfiguration);\r\n    };\r\n    /**\r\n     * This method registers the default rule.\r\n     *\r\n     * The default rule is used when no permission is found for a given permission name when\r\n     * [isPermitted]{@link IPermissionService#isPermitted} is called.\r\n     *\r\n     * ### Throws\r\n     *\r\n     * - Will throw an error if the default rule's names does not contain {@link /smarteditcontainer/miscellaneous/variables.html#DEFAULT_DEFAULT_RULE_NAME default rule name}.\r\n     * - Will throw an error if the default rule has no names array.\r\n     * - Will throw an error if the default rule's names array is empty.\r\n     * - Will throw an error if the default rule has no verify function.\r\n     * - Will throw an error if the default rule's verify parameter is not a function.\r\n     * - Will throw an error if a rule is already registered with a common entry in its names array\r\n     */\r\n    IPermissionService.prototype.registerDefaultRule = function (ruleConfiguration) {\r\n        ruleConfiguration = prepareRuleConfiguration.bind(this)(ruleConfiguration);\r\n        this._registerDefaultRule(ruleConfiguration);\r\n    };\r\n    IPermissionService.prototype.unregisterDefaultRule = function () {\r\n        'proxyFunction';\r\n        return;\r\n    };\r\n    IPermissionService.prototype._registerRule = function (ruleConfiguration) {\r\n        'proxyFunction';\r\n        return;\r\n    };\r\n    IPermissionService.prototype._registerDefaultRule = function (ruleConfiguration) {\r\n        'proxyFunction';\r\n        return;\r\n    };\r\n    return IPermissionService;\r\n}());\r\nexport { IPermissionService };\r\n//# sourceMappingURL=IPermissionService.js.map","references":["/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/dist/index.d.ts"],"map":"{\"version\":3,\"file\":\"IPermissionService.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/services/interfaces/IPermissionService.ts\"],\"names\":[],\"mappings\":\"AAuCA,IAAM,wBAAwB,GAAG,UAAU,iBAAuB;IAC9D,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,mBAAmB,IAAI,EAAE,CAAC;IAC1D,IAAI,CAAC,mBAAmB,CAAC,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG;QAC1D,MAAM,EAAE,iBAAiB,CAAC,MAAM;KACnC,CAAC;IACF,OAAO,iBAAiB,CAAC,MAAM,CAAC;IAEhC,OAAO,iBAAiB,CAAC;AAC7B,CAAC,CAAC;AAEF,IAAM,YAAY,GAAG,UAAU,IAAU;IACrC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,YAAY,KAAK,CAAC,EAAE;QAChC,MAAM,KAAK,CAAC,0BAA0B,CAAC,CAAC;KAC3C;IAED,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;QACvB,MAAM,KAAK,CAAC,iCAAiC,CAAC,CAAC;KAClD;IAED,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;QACd,MAAM,KAAK,CAAC,iCAAiC,CAAC,CAAC;KAClD;IAED,IAAI,OAAO,IAAI,CAAC,MAAM,KAAK,UAAU,EAAE;QACnC,MAAM,KAAK,CAAC,gCAAgC,CAAC,CAAC;KACjD;AACL,CAAC,CAAC;AAEF;;;;;;GAMG;AACH;IAAA;IAkIA,CAAC;IA/HG;;OAEG;IACH,uCAAU,GAAV;QACI,eAAe,CAAC;QAChB,OAAO;IACX,CAAC;IAED;;;;;OAKG;IACH,0CAAa,GAAb,UAAc,UAAkB;QAC5B,eAAe,CAAC;QAChB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;;;;;;;;;;;;;OAgBG;IACH,wCAAW,GAAX,UAAY,WAAyC;QACjD,eAAe,CAAC;QAChB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;;;;;;;;;;;;;;;;;OAoBG;IACH,+CAAkB,GAAlB,UAAmB,UAAsB;QACrC,eAAe,CAAC;QAChB,OAAO;IACX,CAAC;IAED;;;;;;;;;;;;;;;;;;;OAmBG;IACH,yCAAY,GAAZ,UAAa,iBAAuB;QAChC,YAAY,CAAC,iBAAiB,CAAC,CAAC;QAChC,iBAAiB,GAAG,wBAAwB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,iBAAiB,CAAC,CAAC;QAC3E,IAAI,CAAC,aAAa,CAAC,iBAAiB,CAAC,CAAC;IAC1C,CAAC;IAED;;;;;;;;;;;;;;OAcG;IACH,gDAAmB,GAAnB,UAAoB,iBAAuB;QACvC,iBAAiB,GAAG,wBAAwB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,iBAAiB,CAAC,CAAC;QAC3E,IAAI,CAAC,oBAAoB,CAAC,iBAAiB,CAAC,CAAC;IACjD,CAAC;IAED,kDAAqB,GAArB;QACI,eAAe,CAAC;QAChB,OAAO;IACX,CAAC;IAES,0CAAa,GAAvB,UAAwB,iBAAuB;QAC3C,eAAe,CAAC;QAChB,OAAO;IACX,CAAC;IAES,iDAAoB,GAA9B,UAA+B,iBAAuB;QAClD,eAAe,CAAC;QAChB,OAAO;IACX,CAAC;IACL,yBAAC;AAAD,CAAC,AAlID,IAkIC\"}","dts":{"name":"/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/services/interfaces/IPermissionService.d.ts","writeByteOrderMark":false,"text":"import { TypedMap } from '@smart/utils';\r\nexport interface Rule {\r\n    /** The list of names associated to the rule. */\r\n    names: string[];\r\n    /** The verification function of the rule. */\r\n    verify: (permissionObjects?: PermissionContext[]) => Promise<boolean>;\r\n}\r\nexport interface Permission {\r\n    /**\r\n     * The list of aliases associated to the permission. A permission alias must be prefixed by at least one\r\n     * namespace followed by a \".\" character to be valid. i.e. \"se.fake.permission\"\r\n     */\r\n    aliases: string[];\r\n    /**\r\n     * The list of the names of the rules used to verify.\r\n     */\r\n    rules: string[];\r\n}\r\nexport interface MultiNamePermissionContext {\r\n    names: string[];\r\n    context?: TypedMap<any>;\r\n}\r\nexport interface PermissionContext {\r\n    name: string;\r\n    context?: TypedMap<any>;\r\n}\r\nexport interface RuleNames {\r\n    names: string[];\r\n}\r\n/**\r\n * The permission service is used to check if a user has been granted certain permissions.\r\n *\r\n * It is configured with rules and permissions. A rule is used to execute some logic to determine whether or not\r\n * the permission should be granted. A permission references a list of rules. In order for a permission to be\r\n * granted, each rule must be executed successfully and return true.\r\n */\r\nexport declare abstract class IPermissionService {\r\n    ruleVerifyFunctions: TypedMap<{\r\n        verify: (obj: any) => Promise<boolean>;\r\n    }>;\r\n    /**\r\n     * This method clears all cached results in the rules' caches.\r\n     */\r\n    clearCache(): void;\r\n    /**\r\n     * This method returns the registered permission that contains the given name in its\r\n     * array of names.\r\n     *\r\n     * @returns The permission with the given name, undefined otherwise.\r\n     */\r\n    getPermission(permission: string): Permission;\r\n    /**\r\n     * This method checks if a user has been granted certain permissions.\r\n     *\r\n     * It takes an array of permission objects structured as follows:\r\n     *\r\n     * ### Example\r\n     *\r\n     *      {\r\n     *          names: [\"permission.aliases\"],\r\n     *          context: {\r\n     *              data: \"required to check a permission\"\r\n     *          }\r\n     *      }\r\n     *\r\n     *\r\n     * @returns A promise that resolves to true if permission is granted, rejects to false if it isn't and rejects on error.\r\n     */\r\n    isPermitted(permissions: MultiNamePermissionContext[]): Promise<boolean>;\r\n    /**\r\n     * This method registers a permission.\r\n     *\r\n     * A permission is defined by a set of aliases and rules. It is verified by its set of rules.\r\n     * The set of aliases is there for convenience, as there may be different permissions\r\n     * that use the same set of rules to be verified. The permission aliases property\r\n     * will resolve if any one alias is in the aliases' array. Calling [isPermitted]{@link IPermissionService#isPermitted}\r\n     * with any of these aliases will use the same permission object, therefore the same\r\n     * combination of rules to check if the user has the appropriate clearance. This reduces the\r\n     * number of permissions you need to register.\r\n     *\r\n     * ### Throws\r\n     *\r\n     * - Will throw an error if the permission has no aliases array\r\n     * - Will throw an error if the permission's aliases array is empty\r\n     * - Will throw an error if the permission has no rules array\r\n     * - Will throw an error if the permission's rule aliases array is empty\r\n     * - Will throw an error if a permission is already registered with a common entry in its array of aliases\r\n     * - Will throw an error if one of the permission's aliases is not name spaced\r\n     * - Will throw an error if no rule is registered with on of the permission's rule names\r\n     */\r\n    registerPermission(permission: Permission): void;\r\n    /**\r\n     * This method registers a rule. These rules can be used by registering permissions that\r\n     * use them to verify if a user has the appropriate clearance.\r\n     *\r\n     * To avoid accidentally overriding the default rule, an error is thrown when attempting\r\n     * to register a rule with the {@link /smarteditcontainer/miscellaneous/variables.html#DEFAULT_DEFAULT_RULE_NAME default rule name}.\r\n     *\r\n     * To register the default rule, see [registerDefaultRule]{@link IPermissionService#registerDefaultRule}.\r\n     *\r\n     * It must return a promise that responds with true, false, or an error.\r\n     *\r\n     * ### Throws\r\n     *\r\n     * - Will throw an error if the list of rule names contains the reserved {@link /smarteditcontainer/miscellaneous/variables.html#DEFAULT_DEFAULT_RULE_NAME default rule name}.\r\n     * - Will throw an error if the rule has no names array.\r\n     * - Will throw an error if the rule's names array is empty.\r\n     * - Will throw an error if the rule has no verify function.\r\n     * - Will throw an error if the rule's verify parameter is not a function.\r\n     * - Will throw an error if a rule is already registered with a common entry in its names array\r\n     */\r\n    registerRule(ruleConfiguration: Rule): void;\r\n    /**\r\n     * This method registers the default rule.\r\n     *\r\n     * The default rule is used when no permission is found for a given permission name when\r\n     * [isPermitted]{@link IPermissionService#isPermitted} is called.\r\n     *\r\n     * ### Throws\r\n     *\r\n     * - Will throw an error if the default rule's names does not contain {@link /smarteditcontainer/miscellaneous/variables.html#DEFAULT_DEFAULT_RULE_NAME default rule name}.\r\n     * - Will throw an error if the default rule has no names array.\r\n     * - Will throw an error if the default rule's names array is empty.\r\n     * - Will throw an error if the default rule has no verify function.\r\n     * - Will throw an error if the default rule's verify parameter is not a function.\r\n     * - Will throw an error if a rule is already registered with a common entry in its names array\r\n     */\r\n    registerDefaultRule(ruleConfiguration: Rule): void;\r\n    unregisterDefaultRule(): void;\r\n    protected _registerRule(ruleConfiguration: Rule): void;\r\n    protected _registerDefaultRule(ruleConfiguration: Rule): void;\r\n}\r\n"}}
