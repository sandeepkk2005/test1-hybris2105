{"code":"import { __decorate, __metadata } from \"tslib\";\r\n/*\r\n * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.\r\n */\r\nimport { Injectable } from '@angular/core';\r\nimport { LogService } from '@smart/utils';\r\nimport { remove } from 'lodash';\r\nimport { SeDowngradeService } from '../../../di';\r\nimport { BooleanComponent } from '../widgets/BooleanComponent';\r\nimport { DateTimePickerComponent } from '../widgets/DateTimePickerComponent';\r\nimport { DropdownComponent } from '../widgets/DropdownComponent/DropdownComponent';\r\nimport { EditableDropdownComponent } from '../widgets/EditableDropdownComponent';\r\nimport { EmailComponent } from '../widgets/EmailComponent';\r\nimport { EnumComponent } from '../widgets/EnumComponent/EnumComponent';\r\nimport { FloatComponent } from '../widgets/FloatComponent';\r\nimport { LongStringComponent } from '../widgets/LongStringComponent/LongStringComponent';\r\nimport { NumberComponent } from '../widgets/NumberComponent';\r\nimport { RichTextFieldComponent } from '../widgets/RichTextField';\r\nimport { ShortStringComponent } from '../widgets/ShortString/ShortStringComponent';\r\nimport { TextComponent } from '../widgets/TextComponent/TextComponent';\r\n/**\r\n * FLOAT PRECISION\r\n */\r\n/* @internal  */\r\nexport var DEFAULT_GENERIC_EDITOR_FLOAT_PRECISION = '0.01';\r\n/**\r\n * The editorFieldMappingService contains the strategies that the `GenericEditorComponent` component\r\n * uses to control the rendering of a field. When the genericEditor directive is about to display a field, it queries the\r\n * editorFieldMappingService service to retrieve the right strategies to use. Internally, this service makes this selection based on three\r\n * matchers:\r\n * <ul>\r\n * \t<li><b>structureTypeNameMatcher</b>:\tThe matcher for the cmsStructureType of a field.</li>\r\n * \t<li><b>componentTypeNameMatcher</b>:\tThe matcher for the smarteditComponentType of the CMS component containing the field.</li>\r\n * <li><b>discriminatorMatcher</b>:\t\t\tThe matcher for the qualifier used by the genericEditor to identify the field.</li>\r\n * </ul>\r\n * These three matchers are used together to provide finer-grained control on the selection of strategies. A matcher itself is either a\r\n * string or a function that will be used to determine whether a value is considered a match or not. The following list describes\r\n * how a matcher behaves depending on its type:\r\n * <ul>\r\n *  <li><b>String</b>:                      Matches only the parameters that equal the provided string. </li>\r\n *  <li><b>Null</b>:                        Matches any parameter provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>\r\n *  <li><b>Function</b>:                    Matches only the parameters for which the provided callback returns true. This option allows more\r\n *                                          control over the parameters to match.\r\n * </li>\r\n * </ul>\r\n * <br/>\r\n *\r\n * Currently, there are two types of strategies that the genericEditor uses to control the way a field is rendered:\r\n * <ul>\r\n *  <li><b>editor field mapping</b>:        This strategy is used to select and customize which property editor is to be used for this field.</li>\r\n *  <li><b>tab field mapping</b>:           This strategy is used to select the tab in the genericEditor where a field will be positioned.</li>\r\n * </ul>\r\n *\r\n */\r\nvar /* @ngInject */ EditorFieldMappingService = /** @class */ (function () {\r\n    function /* @ngInject */ EditorFieldMappingService(logService) {\r\n        this.logService = logService;\r\n        // --------------------------------------------------------------------------------------\r\n        // Variables\r\n        // --------------------------------------------------------------------------------------\r\n        this._editorsFieldMapping = [];\r\n        this._fieldsTabsMapping = [];\r\n    }\r\n    /* @ngInject */ EditorFieldMappingService_1 = /* @ngInject */ EditorFieldMappingService;\r\n    // --------------------------------------------------------------------------------------\r\n    // Public API\r\n    // --------------------------------------------------------------------------------------\r\n    /**\r\n     * This method overrides the default strategy of the `GenericEditorComponent` directive.\r\n     * used to choose the property editor for a given field. Internally, this selection is based on three matchers:\r\n     * <ul>\r\n     * \t<li><b>structureTypeNameMatcher</b>:\tThe matcher for the cmsStructureType of a field.</li>\r\n     * \t<li><b>componentTypeNameMatcher</b>:\tThe matcher for the smarteditComponentType of the CMS component containing the field.</li>\r\n     * <li><b>discriminatorMatcher</b>:\t\t\tThe matcher for the qualifier used by the genericEditor to identify the field.</li>\r\n     * </ul>\r\n     * Only the fields that match all three matchers will be overriden.\r\n     *\r\n     * The following example shows how some sample fields would match some mappings:\r\n     * <pre>\r\n     * const field1 = {\r\n     * \t\tcmsStructureType: 'ShortString',\r\n     * \t\tsmarteditComponentType: 'CmsParagraphComponent',\r\n     * \t\tqualifier: 'name'\r\n     * };\r\n     *\r\n     *  const field2 = {\r\n     *      cmsStructureType: 'Boolean',\r\n     *      smarteditComponentType: 'CmsParagraphComponent',\r\n     *      qualifier: 'visible'\r\n     *  };\r\n     * </pre>\r\n     *\r\n     * <pre>\r\n     * // This mapping won't match any of the fields. They don't match all three matchers.\r\n     * editorFieldMappingService.addFieldMapping(\r\n     *  'ShortString', 'CmsParagraphComponent', 'visible', configuration);\r\n     *\r\n     * // This mapping will match field2. It matches all three matchers perfectly.\r\n     * editorFieldMappingService.addFieldMapping(\r\n     *  'Boolean', 'CmsParagraphComponent', 'visible', configuration);\r\n     *\r\n     * // This mapping will match both fields. They match all three matchers.\r\n     * // Note that both null and '*' represent a wildcard that accepts any value.\r\n     * editorFieldMappingService.addFieldMapping(\r\n     *  null, 'CmsParagraphComponent', '*', configuration);\r\n     * </pre>\r\n     *\r\n     * <b>Note:</b> <br/>\r\n     * The genericEditor has some predefined editors for the following cmsStructureTypes:\r\n     * <ul>\r\n     * \t\t<li><b>ShortString</b>:\t\t\tDisplays a text input field.</li>\r\n     * \t\t<li><b>LongString</b>:  \t\tDisplays a text area.</li>\r\n     * \t\t<li><b>RichText</b>:    \t\tDisplays an HTML/rich text editor.</li>\r\n     * \t\t<li><b>Boolean</b>:     \t\tDisplays a check box.</li>\r\n     * \t\t<li><b>DateTime</b>:        \tDisplays an input field with a date-time picker.</li>\r\n     * \t\t<li><b>Media</b>:       \t\tDisplays a filterable dropdown list of media</li>\r\n     * \t\t<li><b>Enum</b>:\t\t \t\tDisplays a filterable dropdown list of the enum class values identified by cmsStructureEnumType property.\r\n     * \t\t<li><b>EditableDropdown</b>: \tDisplays a configurable dropdown list that is enabled by `GenericEditorDropdownComponent`.\r\n     * </ul>\r\n     * <br />\r\n     * You can program the `GenericEditorComponent` to use other property editors for these\r\n     * cmsStructureTypes. You can also add custom cmsStructureTypes.\r\n     * All default and custom property editors are HTML templates. These templates must adhere to the PropertyEditorTemplate {@link PropertyEditorTemplate contract}.\r\n     *\r\n     * @param structureTypeName The matcher used to identify the cmsStructureTypes for which a custom property editor is\r\n     * required.\r\n     * There are three possible values for this parameter:\r\n     *  <li><b>String</b>:                      Matches only the cmsStructureTypes whose name equals this string. </li>\r\n     *  <li><b>Null</b>:                        Matches any cmsStructureType provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>\r\n     *  <li><b>Function</b>:                    Matches only the cmsStructureTypes for which the provided callback returns true. This option allows more\r\n     *                                          control over the types to match.\r\n     *\r\n     * This function will be called with three parameters:\r\n     * <ul>\r\n     *  <li><b>cmsStructureType:</b>           The cmsStructureType of the field.</li>\r\n     *  <li><b>field:</b>                      The field to evaluate.</li>\r\n     *  <li><b>componentTypeStructure:</b>     The smarteditComponentType structure of the CMS component that contains the field to evaluate.</li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * @param componentTypeName The matcher used to identify the smarteditComponentType for which a custom property editor is\r\n     * required.\r\n     * There are three possible values for this parameter:\r\n     *  <li><b>String</b>:                      Matches only the smarteditComponentType whose name equals this string. </li>\r\n     *  <li><b>Null</b>:                        Matches any smarteditComponentType provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>\r\n     *  <li><b>Function</b>:                    Matches only the smarteditComponentType for which the provided callback returns true. This option allows more\r\n     *                                          control over the types to match.\r\n     *\r\n     * This function will be called with three parameters:\r\n     * <ul>\r\n     *  <li><b>componentTypeName:</b>         The smarteditComponentType name of the field. </li>\r\n     *  <li><b>field:</b>                     The field to evaluate. </li>\r\n     *  <li><b>componentTypeStructure:</b>    The smarteditComponentType structure of the CMS component that contains the field to evaluate.</li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * @param discriminator The matcher used to identify the discriminator for which a custom property editor is\r\n     * required.\r\n     * There are three possible values for this parameter:\r\n     *  <li><b>String</b>:                      Matches only the discriminators whose name equals this string. </li>\r\n     *  <li><b>Null</b>:                        Matches any discriminator provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>\r\n     *  <li><b>Function</b>:                    Matches only the discriminators for which the provided callback returns true. This option allows more\r\n     *                                          control over the types to match.\r\n     *\r\n     * This function will be called with three parameters:\r\n     * <ul>\r\n     *  <li><b>discriminator</b>:               The discriminator of the field to evaluate. </li>\r\n     *  <li><b>field:</b>                       The field to evaluate. </li>\r\n     *  <li><b>componentTypeStructure:</b>      The smarteditComponentType of the component that contains the field to evaluate.</li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * @param configuration The holder that contains the override instructions. Cannot be null.\r\n     * @param configuration.template The path to the HTML template used in the override. Cannot be null.\r\n     * @param  configuration.customSanitize Custom sanitize function for a custom property editor. It's provided with a payload and\r\n     * an optional `functionsModule.sanitize` function.\r\n     */\r\n    /* @ngInject */ EditorFieldMappingService.prototype.addFieldMapping = function (structureTypeName, componentTypeName, discriminator, configuration) {\r\n        this._addMapping(structureTypeName, componentTypeName, discriminator, configuration, this._editorsFieldMapping);\r\n    };\r\n    /**\r\n     * This method is used by the genericEditor to retrieve the property editor to be rendered in a generic editor, along with its configuration.\r\n     * If more than one property editor could be applied to the provided field, the one with the most accurate match will be used.\r\n     *\r\n     * Note:\r\n     * Currently, all templates in SmartEdit use the short form. Before returning a response, this method ensures that\r\n     * the template provided to the generic editor is in short form. For example:\r\n     * - A template 'genericEditor/templates/shortStringTemplate.html' will be transformed to 'shortStringTemplate.html'\r\n     *\r\n     * @param field The object that represents the field that the property editor is retrieved for.\r\n     * @param field.cmsStructureType The cmsStructureType that the property editor is retrieved for.\r\n     * @param field.smarteditComponentType The smarteditComponentType that the property editor is retrieved for.\r\n     * @param field.qualifier The field name of the smarteditComponentType that the property editor is retrieved for.\r\n     * @param componentTypeStructure The smarteditComponentType structure of the componenent that contains the field that the property editor\r\n     * is retrieved for.\r\n     * @returns The configuration of the property editor to be used for this field. Can be null if no adequate match is found.\r\n     *\r\n     */\r\n    /* @ngInject */ EditorFieldMappingService.prototype.getEditorFieldMapping = function (field, componentTypeStructure) {\r\n        var fieldMapping = this._getMapping(field, componentTypeStructure, this._editorsFieldMapping);\r\n        if (!fieldMapping) {\r\n            this.logService.warn('editorFieldMappingService - Cannot find suitable field mapping for type ', field.cmsStructureType);\r\n            fieldMapping = null;\r\n        }\r\n        else if (fieldMapping && fieldMapping.template) {\r\n            fieldMapping.template = this._cleanTemplate(fieldMapping.template);\r\n        }\r\n        return fieldMapping;\r\n    };\r\n    /**\r\n     * This method overrides the default strategy of the `GenericEditorComponent` directive\r\n     * used to choose the tab where to render a field in the generic editor. Internally, this selection is based on three elements:\r\n     * <ul>\r\n     * \t<li><b>structureTypeName</b>:\t\t\tThe cmsStructureType of a field.</li>\r\n     * \t<li><b>componentTypeName</b>:\t\t\tThe smarteditComponentType of the component containing the field.</li>\r\n     * <li><b>discriminator</b>:\t\t\t    The qualifier used by the genericEditor to identify the field.</li>\r\n     * </ul>\r\n     * Only the fields that match all three elements will be overriden.\r\n     *\r\n     * The following example shows how sample fields would match some mappings:\r\n     * <pre>\r\n     *  const field1 = {\r\n     *      cmsStructureType: 'ShortString',\r\n     *      smarteditComponentType: 'CmsParagraphComponent',\r\n     *      qualifier: 'name'\r\n     *  };\r\n     *\r\n     *  const field2 = {\r\n     *      cmsStructureType: 'Boolean',\r\n     *      smarteditComponentType: 'CmsParagraphComponent',\r\n     *      qualifier: 'visible'\r\n     *  };\r\n     * </pre>\r\n     *\r\n     * <pre>\r\n     * // This mapping won't match any of the fields. They don't match all three matchers.\r\n     * editorFieldMappingService.addFieldTabMapping(\r\n     *  'ShortString', 'CmsParagraphComponent', 'visible', tabId);\r\n     *\r\n     * // This mapping will match field2. It matches all three matchers perfectly.\r\n     * editorFieldMappingService.addFieldTabMapping(\r\n     *  'Boolean', 'CmsParagraphComponent', 'visible', tabId);\r\n     *\r\n     * // This mapping will match both fields. They match all three matchers.\r\n     * // Note that both null and '*' represent a wildcard that accepts any value.\r\n     * editorFieldMappingService.addFieldTabMapping(\r\n     *  null, 'CmsParagraphComponent', '*', tabId);\r\n     * </pre>\r\n     *\r\n     * @param structureTypeNameMatcher The matcher used to identify the cmsStructureTypes for which to find its tab.\r\n     * There are three possible values for this parameter:\r\n     *  <li><b>String</b>:                      Matches only the cmsStructureTypes whose name equals this string. </li>\r\n     *  <li><b>Null</b>:                        Matches any cmsStructureType provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>\r\n     *  <li><b>Function</b>:                    Matches only the cmsStructureTypes for which the provided callback returns true. This option allows more\r\n     *                                          control over the types to match.\r\n     *\r\n     * This function will be called with three parameters:\r\n     * <ul>\r\n     *  <li><b>cmsStructureType:</b>           The cmsStructureType of the field.</li>\r\n     *  <li><b>field:</b>                      The field to evaluate.</li>\r\n     *  <li><b>componentTypeStructure:</b>     The smarteditComponentType structure of the CMS component that contains the field to evaluate.</li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * @param {String | Function} componentTypeName The matcher used to identify the smarteditComponentType for which for which to find its tab.\r\n     * There are three possible values for this parameter:\r\n     *  <li><b>String</b>:                      Matches only the smarteditComponentType whose name equals this string. </li>\r\n     *  <li><b>Null</b>:                        Matches any smarteditComponentType provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>\r\n     *  <li><b>Function</b>:                    Matches only the smarteditComponentType for which the provided callback returns true. This option allows more\r\n     *                                          control over the types to match.\r\n     *\r\n     * This function will be called with three parameters:\r\n     * <ul>\r\n     *  <li><b>componentTypeName:</b>         The smarteditComponentType name of the field. </li>\r\n     *  <li><b>field:</b>                     The field to evaluate. </li>\r\n     *  <li><b>componentTypeStructure:</b>    The smarteditComponentType structure of the CMS component that contains the field to evaluate.</li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * @param discriminator The matcher used to identify the discriminator for which for which to find its tab.\r\n     * There are three possible values for this parameter:\r\n     *  <li><b>String</b>:                      Matches only the discriminators whose name equals this string. </li>\r\n     *  <li><b>Null</b>:                        Matches any discriminator provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>\r\n     *  <li><b>Function</b>:                    Matches only the discriminators for which the provided callback returns true. This option allows more\r\n     *                                          control over the types to match.\r\n     *\r\n     * This function will be called with three parameters:\r\n     * <ul>\r\n     *  <li><b>discriminator</b>:               The discriminator of the field to evaluate. </li>\r\n     *  <li><b>field:</b>                       The field to evaluate. </li>\r\n     *  <li><b>componentTypeStructure:</b>      The smarteditComponentType of the component that contains the field to evaluate.</li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * @param tabId The ID of the tab where the field must be rendered in the generic editor.\r\n     */\r\n    /* @ngInject */ EditorFieldMappingService.prototype.addFieldTabMapping = function (structureTypeName, componentTypeName, discriminator, tabId) {\r\n        this._addMapping(structureTypeName, componentTypeName, discriminator, tabId, this._fieldsTabsMapping);\r\n    };\r\n    /**\r\n     * This method is used by the genericEditor to retrieve the tab where the field will be rendered in the generic editor.\r\n     * If more than one tab matches the field provided, then the tab with the most accurate match will be used.\r\n     *\r\n     * @param field The object that represents the field that the tab is retrieved for.\r\n     * @param field.cmsStructureType The cmsStructureType that the tab is retrieved for.\r\n     * @param field.smarteditComponentType The smarteditComponentType that the tab is retrieved for.\r\n     * @param field.qualifier The field name of the smarteditComponentType that the tab is retrieved for.\r\n     * @param componentTypeStructure The smarteditComponentType structure of the component that contains the field that the tab is retrieved for.\r\n     * @returns The ID of the tab where this field must reside. Can be null if no adequate match is found.\r\n     *\r\n     */\r\n    /* @ngInject */ EditorFieldMappingService.prototype.getFieldTabMapping = function (field, componentTypeStructure) {\r\n        return this._getMapping(field, componentTypeStructure, this._fieldsTabsMapping);\r\n    };\r\n    // --------------------------------------------------------------------------------------\r\n    // Helper Methods\r\n    // --------------------------------------------------------------------------------------\r\n    /* @ngInject */ EditorFieldMappingService.prototype._addMapping = function (structureTypeMatcher, componentTypeMatcher, discriminatorMatcher, mappedValue, collection) {\r\n        structureTypeMatcher = this._validateField(structureTypeMatcher);\r\n        componentTypeMatcher = this._validateField(componentTypeMatcher);\r\n        discriminatorMatcher = this._validateField(discriminatorMatcher);\r\n        var newMapping = {\r\n            structureTypeMatcher: structureTypeMatcher,\r\n            componentTypeMatcher: componentTypeMatcher,\r\n            discriminatorMatcher: discriminatorMatcher,\r\n            value: mappedValue\r\n        };\r\n        remove(collection, function (element) {\r\n            return element.structureTypeMatcher === structureTypeMatcher &&\r\n                element.componentTypeMatcher === componentTypeMatcher &&\r\n                element.discriminatorMatcher === discriminatorMatcher;\r\n        });\r\n        collection.push(newMapping);\r\n    };\r\n    /* @ngInject */ EditorFieldMappingService.prototype._validateField = function (field) {\r\n        if (field === null) {\r\n            field = /* @ngInject */ EditorFieldMappingService_1.WILDCARD;\r\n        }\r\n        else if (typeof field !== 'string' && typeof field !== 'function') {\r\n            throw new Error('editorFieldMappingService: Mapping matcher must be of type string or function.');\r\n        }\r\n        return field;\r\n    };\r\n    /* @ngInject */ EditorFieldMappingService.prototype._getMapping = function (field, componentTypeStructure, collection) {\r\n        var _this = this;\r\n        var result = null;\r\n        var maxValue = 0;\r\n        collection.forEach(function (mappingEntry) {\r\n            var mappingValue = _this._evaluateMapping(mappingEntry, field, componentTypeStructure);\r\n            if (mappingValue > maxValue) {\r\n                result = mappingEntry.value;\r\n                maxValue = mappingValue;\r\n            }\r\n        });\r\n        return result;\r\n    };\r\n    /* @ngInject */ EditorFieldMappingService.prototype._evaluateMapping = function (mappingEntry, field, componentTypeStructure) {\r\n        var componentTypeMatch;\r\n        var discriminatorMatch;\r\n        var mappingMatch = /* @ngInject */ EditorFieldMappingService_1.MATCH.NONE;\r\n        var structureTypeMatch = this._evaluateMatcher(mappingEntry.structureTypeMatcher, field.cmsStructureType, field, componentTypeStructure);\r\n        if (structureTypeMatch !== /* @ngInject */ EditorFieldMappingService_1.MATCH.NONE) {\r\n            componentTypeMatch = this._evaluateMatcher(mappingEntry.componentTypeMatcher, field.smarteditComponentType, field, componentTypeStructure);\r\n            if (componentTypeMatch !== /* @ngInject */ EditorFieldMappingService_1.MATCH.NONE) {\r\n                discriminatorMatch = this._evaluateMatcher(mappingEntry.discriminatorMatcher, field.qualifier, field, componentTypeStructure);\r\n            }\r\n        }\r\n        if (structureTypeMatch !== /* @ngInject */ EditorFieldMappingService_1.MATCH.NONE &&\r\n            componentTypeMatch !== /* @ngInject */ EditorFieldMappingService_1.MATCH.NONE &&\r\n            discriminatorMatch !== /* @ngInject */ EditorFieldMappingService_1.MATCH.NONE) {\r\n            mappingMatch = structureTypeMatch + componentTypeMatch + discriminatorMatch;\r\n        }\r\n        return mappingMatch;\r\n    };\r\n    /* @ngInject */ EditorFieldMappingService.prototype._evaluateMatcher = function (matcher, actualValue, field, componentTypeStructure) {\r\n        if (typeof matcher === 'string') {\r\n            if (matcher === /* @ngInject */ EditorFieldMappingService_1.WILDCARD) {\r\n                return /* @ngInject */ EditorFieldMappingService_1.MATCH.PARTIAL;\r\n            }\r\n            else {\r\n                return this._exactValueMatchPredicate(matcher, actualValue)\r\n                    ? /* @ngInject */ EditorFieldMappingService_1.MATCH.EXACT\r\n                    : /* @ngInject */ EditorFieldMappingService_1.MATCH.NONE;\r\n            }\r\n        }\r\n        else {\r\n            return matcher(actualValue, field, componentTypeStructure)\r\n                ? /* @ngInject */ EditorFieldMappingService_1.MATCH.EXACT\r\n                : /* @ngInject */ EditorFieldMappingService_1.MATCH.NONE;\r\n        }\r\n    };\r\n    /* @ngInject */ EditorFieldMappingService.prototype._registerDefaultFieldMappings = function () {\r\n        if (!this._initialized) {\r\n            this._initialized = true;\r\n            this.addFieldMapping('Boolean', null, null, {\r\n                component: BooleanComponent\r\n            });\r\n            this.addFieldMapping('ShortString', null, null, {\r\n                component: ShortStringComponent\r\n            });\r\n            this.addFieldMapping('Text', null, null, {\r\n                component: TextComponent\r\n            });\r\n            this.addFieldMapping('LongString', null, null, {\r\n                component: LongStringComponent\r\n            });\r\n            this.addFieldMapping('RichText', null, null, {\r\n                component: RichTextFieldComponent\r\n            });\r\n            this.addFieldMapping('Number', null, null, {\r\n                component: NumberComponent\r\n            });\r\n            this.addFieldMapping('Float', null, null, {\r\n                component: FloatComponent\r\n            });\r\n            this.addFieldMapping('Dropdown', null, null, {\r\n                component: DropdownComponent\r\n            });\r\n            this.addFieldMapping('EditableDropdown', null, null, {\r\n                component: EditableDropdownComponent\r\n            });\r\n            this.addFieldMapping('DateTime', null, null, {\r\n                component: DateTimePickerComponent\r\n            });\r\n            this.addFieldMapping('Enum', null, null, {\r\n                component: EnumComponent\r\n            });\r\n            this.addFieldMapping('Email', null, null, {\r\n                component: EmailComponent,\r\n                validators: {\r\n                    email: function (id, structure, required, component) { return true; }\r\n                }\r\n            });\r\n        }\r\n    };\r\n    /* @ngInject */ EditorFieldMappingService.prototype._cleanTemplate = function (template) {\r\n        var index = template ? template.lastIndexOf('/') : -1;\r\n        if (index !== -1) {\r\n            template = template.substring(index + 1);\r\n        }\r\n        return template;\r\n    };\r\n    // --------------------------------------------------------------------------------------\r\n    // Predicates\r\n    // --------------------------------------------------------------------------------------\r\n    /* @ngInject */ EditorFieldMappingService.prototype._exactValueMatchPredicate = function (expectedValue, actualValue) {\r\n        return expectedValue === actualValue;\r\n    };\r\n    var /* @ngInject */ EditorFieldMappingService_1;\r\n    // --------------------------------------------------------------------------------------\r\n    // Constants\r\n    // --------------------------------------------------------------------------------------\r\n    /* @ngInject */ EditorFieldMappingService.WILDCARD = '*';\r\n    /* @ngInject */ EditorFieldMappingService.MATCH = {\r\n        NONE: 0,\r\n        PARTIAL: 1,\r\n        EXACT: 4 // An exact match is always better than a partial.\r\n    };\r\n    /* @ngInject */ EditorFieldMappingService = /* @ngInject */ EditorFieldMappingService_1 = __decorate([\r\n        SeDowngradeService(),\r\n        Injectable(),\r\n        __metadata(\"design:paramtypes\", [LogService])\r\n    ], /* @ngInject */ EditorFieldMappingService);\r\n    return /* @ngInject */ EditorFieldMappingService;\r\n}());\r\nexport { /* @ngInject */ EditorFieldMappingService };\r\n//# sourceMappingURL=EditorFieldMappingService.js.map","references":["/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedittools/common/temp/node_modules/.pnpm/@angular/core@8.2.14_rxjs@6.5.4+zone.js@0.9.1/node_modules/@angular/core/core.d.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/dist/index.d.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedittools/common/temp/node_modules/.pnpm/@types/lodash@4.14.159/node_modules/@types/lodash/ts3.1/index.d.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/src/di/index.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/src/components/genericEditor/types.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/src/components/genericEditor/widgets/BooleanComponent/index.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/src/components/genericEditor/widgets/DateTimePickerComponent/index.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/src/components/genericEditor/widgets/DropdownComponent/DropdownComponent.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/src/components/genericEditor/widgets/EditableDropdownComponent/index.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/src/components/genericEditor/widgets/EmailComponent/index.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/src/components/genericEditor/widgets/EnumComponent/EnumComponent.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/src/components/genericEditor/widgets/FloatComponent/index.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/src/components/genericEditor/widgets/LongStringComponent/LongStringComponent.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/src/components/genericEditor/widgets/NumberComponent/index.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/src/components/genericEditor/widgets/RichTextField/index.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/src/components/genericEditor/widgets/ShortString/ShortStringComponent.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/src/components/genericEditor/widgets/TextComponent/TextComponent.ts"],"map":"{\"version\":3,\"file\":\"EditorFieldMappingService.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/components/genericEditor/services/EditorFieldMappingService.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smartedit-commons/components/genericEditor/services/EditorFieldMappingService.d.ts","writeByteOrderMark":false,"text":"import { LogService } from '@smart/utils';\r\nimport { GenericEditorField, GenericEditorMapping, GenericEditorMappingConfiguration, GenericEditorStructure } from '../types';\r\n/**\r\n * FLOAT PRECISION\r\n */\r\nexport declare const DEFAULT_GENERIC_EDITOR_FLOAT_PRECISION = \"0.01\";\r\n/**\r\n * The purpose of the property editor template is to assign a value to model[qualifier].\r\n * In order to do this, all templates receive the following entities in their scope:\r\n */\r\n/** @internal */\r\nexport interface PropertyEditorTemplate {\r\n    /** The field description of the field being edited as defined by the structure API described in `IGenericEditor` */\r\n    field: GenericEditorField;\r\n    /** If the field is not localized, this is the actual field.qualifier, if it is localized, it is the language identifier such as en, de... */\r\n    qualifier: string;\r\n    /** If the field is not localized, this is the actual full parent model object, if it is localized, it is the language map: model[field.qualifier]. */\r\n    model: any;\r\n}\r\n/**\r\n * The editorFieldMappingService contains the strategies that the `GenericEditorComponent` component\r\n * uses to control the rendering of a field. When the genericEditor directive is about to display a field, it queries the\r\n * editorFieldMappingService service to retrieve the right strategies to use. Internally, this service makes this selection based on three\r\n * matchers:\r\n * <ul>\r\n * \t<li><b>structureTypeNameMatcher</b>:\tThe matcher for the cmsStructureType of a field.</li>\r\n * \t<li><b>componentTypeNameMatcher</b>:\tThe matcher for the smarteditComponentType of the CMS component containing the field.</li>\r\n * <li><b>discriminatorMatcher</b>:\t\t\tThe matcher for the qualifier used by the genericEditor to identify the field.</li>\r\n * </ul>\r\n * These three matchers are used together to provide finer-grained control on the selection of strategies. A matcher itself is either a\r\n * string or a function that will be used to determine whether a value is considered a match or not. The following list describes\r\n * how a matcher behaves depending on its type:\r\n * <ul>\r\n *  <li><b>String</b>:                      Matches only the parameters that equal the provided string. </li>\r\n *  <li><b>Null</b>:                        Matches any parameter provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>\r\n *  <li><b>Function</b>:                    Matches only the parameters for which the provided callback returns true. This option allows more\r\n *                                          control over the parameters to match.\r\n * </li>\r\n * </ul>\r\n * <br/>\r\n *\r\n * Currently, there are two types of strategies that the genericEditor uses to control the way a field is rendered:\r\n * <ul>\r\n *  <li><b>editor field mapping</b>:        This strategy is used to select and customize which property editor is to be used for this field.</li>\r\n *  <li><b>tab field mapping</b>:           This strategy is used to select the tab in the genericEditor where a field will be positioned.</li>\r\n * </ul>\r\n *\r\n */\r\nexport declare class EditorFieldMappingService {\r\n    private logService;\r\n    private static readonly WILDCARD;\r\n    private static readonly MATCH;\r\n    _editorsFieldMapping: GenericEditorMapping[];\r\n    _fieldsTabsMapping: GenericEditorMapping[];\r\n    private _initialized;\r\n    constructor(logService: LogService);\r\n    /**\r\n     * This method overrides the default strategy of the `GenericEditorComponent` directive.\r\n     * used to choose the property editor for a given field. Internally, this selection is based on three matchers:\r\n     * <ul>\r\n     * \t<li><b>structureTypeNameMatcher</b>:\tThe matcher for the cmsStructureType of a field.</li>\r\n     * \t<li><b>componentTypeNameMatcher</b>:\tThe matcher for the smarteditComponentType of the CMS component containing the field.</li>\r\n     * <li><b>discriminatorMatcher</b>:\t\t\tThe matcher for the qualifier used by the genericEditor to identify the field.</li>\r\n     * </ul>\r\n     * Only the fields that match all three matchers will be overriden.\r\n     *\r\n     * The following example shows how some sample fields would match some mappings:\r\n     * <pre>\r\n     * const field1 = {\r\n     * \t\tcmsStructureType: 'ShortString',\r\n     * \t\tsmarteditComponentType: 'CmsParagraphComponent',\r\n     * \t\tqualifier: 'name'\r\n     * };\r\n     *\r\n     *  const field2 = {\r\n     *      cmsStructureType: 'Boolean',\r\n     *      smarteditComponentType: 'CmsParagraphComponent',\r\n     *      qualifier: 'visible'\r\n     *  };\r\n     * </pre>\r\n     *\r\n     * <pre>\r\n     * // This mapping won't match any of the fields. They don't match all three matchers.\r\n     * editorFieldMappingService.addFieldMapping(\r\n     *  'ShortString', 'CmsParagraphComponent', 'visible', configuration);\r\n     *\r\n     * // This mapping will match field2. It matches all three matchers perfectly.\r\n     * editorFieldMappingService.addFieldMapping(\r\n     *  'Boolean', 'CmsParagraphComponent', 'visible', configuration);\r\n     *\r\n     * // This mapping will match both fields. They match all three matchers.\r\n     * // Note that both null and '*' represent a wildcard that accepts any value.\r\n     * editorFieldMappingService.addFieldMapping(\r\n     *  null, 'CmsParagraphComponent', '*', configuration);\r\n     * </pre>\r\n     *\r\n     * <b>Note:</b> <br/>\r\n     * The genericEditor has some predefined editors for the following cmsStructureTypes:\r\n     * <ul>\r\n     * \t\t<li><b>ShortString</b>:\t\t\tDisplays a text input field.</li>\r\n     * \t\t<li><b>LongString</b>:  \t\tDisplays a text area.</li>\r\n     * \t\t<li><b>RichText</b>:    \t\tDisplays an HTML/rich text editor.</li>\r\n     * \t\t<li><b>Boolean</b>:     \t\tDisplays a check box.</li>\r\n     * \t\t<li><b>DateTime</b>:        \tDisplays an input field with a date-time picker.</li>\r\n     * \t\t<li><b>Media</b>:       \t\tDisplays a filterable dropdown list of media</li>\r\n     * \t\t<li><b>Enum</b>:\t\t \t\tDisplays a filterable dropdown list of the enum class values identified by cmsStructureEnumType property.\r\n     * \t\t<li><b>EditableDropdown</b>: \tDisplays a configurable dropdown list that is enabled by `GenericEditorDropdownComponent`.\r\n     * </ul>\r\n     * <br />\r\n     * You can program the `GenericEditorComponent` to use other property editors for these\r\n     * cmsStructureTypes. You can also add custom cmsStructureTypes.\r\n     * All default and custom property editors are HTML templates. These templates must adhere to the PropertyEditorTemplate {@link PropertyEditorTemplate contract}.\r\n     *\r\n     * @param structureTypeName The matcher used to identify the cmsStructureTypes for which a custom property editor is\r\n     * required.\r\n     * There are three possible values for this parameter:\r\n     *  <li><b>String</b>:                      Matches only the cmsStructureTypes whose name equals this string. </li>\r\n     *  <li><b>Null</b>:                        Matches any cmsStructureType provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>\r\n     *  <li><b>Function</b>:                    Matches only the cmsStructureTypes for which the provided callback returns true. This option allows more\r\n     *                                          control over the types to match.\r\n     *\r\n     * This function will be called with three parameters:\r\n     * <ul>\r\n     *  <li><b>cmsStructureType:</b>           The cmsStructureType of the field.</li>\r\n     *  <li><b>field:</b>                      The field to evaluate.</li>\r\n     *  <li><b>componentTypeStructure:</b>     The smarteditComponentType structure of the CMS component that contains the field to evaluate.</li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * @param componentTypeName The matcher used to identify the smarteditComponentType for which a custom property editor is\r\n     * required.\r\n     * There are three possible values for this parameter:\r\n     *  <li><b>String</b>:                      Matches only the smarteditComponentType whose name equals this string. </li>\r\n     *  <li><b>Null</b>:                        Matches any smarteditComponentType provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>\r\n     *  <li><b>Function</b>:                    Matches only the smarteditComponentType for which the provided callback returns true. This option allows more\r\n     *                                          control over the types to match.\r\n     *\r\n     * This function will be called with three parameters:\r\n     * <ul>\r\n     *  <li><b>componentTypeName:</b>         The smarteditComponentType name of the field. </li>\r\n     *  <li><b>field:</b>                     The field to evaluate. </li>\r\n     *  <li><b>componentTypeStructure:</b>    The smarteditComponentType structure of the CMS component that contains the field to evaluate.</li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * @param discriminator The matcher used to identify the discriminator for which a custom property editor is\r\n     * required.\r\n     * There are three possible values for this parameter:\r\n     *  <li><b>String</b>:                      Matches only the discriminators whose name equals this string. </li>\r\n     *  <li><b>Null</b>:                        Matches any discriminator provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>\r\n     *  <li><b>Function</b>:                    Matches only the discriminators for which the provided callback returns true. This option allows more\r\n     *                                          control over the types to match.\r\n     *\r\n     * This function will be called with three parameters:\r\n     * <ul>\r\n     *  <li><b>discriminator</b>:               The discriminator of the field to evaluate. </li>\r\n     *  <li><b>field:</b>                       The field to evaluate. </li>\r\n     *  <li><b>componentTypeStructure:</b>      The smarteditComponentType of the component that contains the field to evaluate.</li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * @param configuration The holder that contains the override instructions. Cannot be null.\r\n     * @param configuration.template The path to the HTML template used in the override. Cannot be null.\r\n     * @param  configuration.customSanitize Custom sanitize function for a custom property editor. It's provided with a payload and\r\n     * an optional `functionsModule.sanitize` function.\r\n     */\r\n    addFieldMapping(structureTypeName: string | ((...args: any[]) => boolean), componentTypeName: string | ((...args: any[]) => boolean), discriminator: string | ((...args: any[]) => boolean), configuration: GenericEditorMappingConfiguration): void;\r\n    /**\r\n     * This method is used by the genericEditor to retrieve the property editor to be rendered in a generic editor, along with its configuration.\r\n     * If more than one property editor could be applied to the provided field, the one with the most accurate match will be used.\r\n     *\r\n     * Note:\r\n     * Currently, all templates in SmartEdit use the short form. Before returning a response, this method ensures that\r\n     * the template provided to the generic editor is in short form. For example:\r\n     * - A template 'genericEditor/templates/shortStringTemplate.html' will be transformed to 'shortStringTemplate.html'\r\n     *\r\n     * @param field The object that represents the field that the property editor is retrieved for.\r\n     * @param field.cmsStructureType The cmsStructureType that the property editor is retrieved for.\r\n     * @param field.smarteditComponentType The smarteditComponentType that the property editor is retrieved for.\r\n     * @param field.qualifier The field name of the smarteditComponentType that the property editor is retrieved for.\r\n     * @param componentTypeStructure The smarteditComponentType structure of the componenent that contains the field that the property editor\r\n     * is retrieved for.\r\n     * @returns The configuration of the property editor to be used for this field. Can be null if no adequate match is found.\r\n     *\r\n     */\r\n    getEditorFieldMapping(field: GenericEditorField, componentTypeStructure: GenericEditorStructure): any;\r\n    /**\r\n     * This method overrides the default strategy of the `GenericEditorComponent` directive\r\n     * used to choose the tab where to render a field in the generic editor. Internally, this selection is based on three elements:\r\n     * <ul>\r\n     * \t<li><b>structureTypeName</b>:\t\t\tThe cmsStructureType of a field.</li>\r\n     * \t<li><b>componentTypeName</b>:\t\t\tThe smarteditComponentType of the component containing the field.</li>\r\n     * <li><b>discriminator</b>:\t\t\t    The qualifier used by the genericEditor to identify the field.</li>\r\n     * </ul>\r\n     * Only the fields that match all three elements will be overriden.\r\n     *\r\n     * The following example shows how sample fields would match some mappings:\r\n     * <pre>\r\n     *  const field1 = {\r\n     *      cmsStructureType: 'ShortString',\r\n     *      smarteditComponentType: 'CmsParagraphComponent',\r\n     *      qualifier: 'name'\r\n     *  };\r\n     *\r\n     *  const field2 = {\r\n     *      cmsStructureType: 'Boolean',\r\n     *      smarteditComponentType: 'CmsParagraphComponent',\r\n     *      qualifier: 'visible'\r\n     *  };\r\n     * </pre>\r\n     *\r\n     * <pre>\r\n     * // This mapping won't match any of the fields. They don't match all three matchers.\r\n     * editorFieldMappingService.addFieldTabMapping(\r\n     *  'ShortString', 'CmsParagraphComponent', 'visible', tabId);\r\n     *\r\n     * // This mapping will match field2. It matches all three matchers perfectly.\r\n     * editorFieldMappingService.addFieldTabMapping(\r\n     *  'Boolean', 'CmsParagraphComponent', 'visible', tabId);\r\n     *\r\n     * // This mapping will match both fields. They match all three matchers.\r\n     * // Note that both null and '*' represent a wildcard that accepts any value.\r\n     * editorFieldMappingService.addFieldTabMapping(\r\n     *  null, 'CmsParagraphComponent', '*', tabId);\r\n     * </pre>\r\n     *\r\n     * @param structureTypeNameMatcher The matcher used to identify the cmsStructureTypes for which to find its tab.\r\n     * There are three possible values for this parameter:\r\n     *  <li><b>String</b>:                      Matches only the cmsStructureTypes whose name equals this string. </li>\r\n     *  <li><b>Null</b>:                        Matches any cmsStructureType provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>\r\n     *  <li><b>Function</b>:                    Matches only the cmsStructureTypes for which the provided callback returns true. This option allows more\r\n     *                                          control over the types to match.\r\n     *\r\n     * This function will be called with three parameters:\r\n     * <ul>\r\n     *  <li><b>cmsStructureType:</b>           The cmsStructureType of the field.</li>\r\n     *  <li><b>field:</b>                      The field to evaluate.</li>\r\n     *  <li><b>componentTypeStructure:</b>     The smarteditComponentType structure of the CMS component that contains the field to evaluate.</li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * @param {String | Function} componentTypeName The matcher used to identify the smarteditComponentType for which for which to find its tab.\r\n     * There are three possible values for this parameter:\r\n     *  <li><b>String</b>:                      Matches only the smarteditComponentType whose name equals this string. </li>\r\n     *  <li><b>Null</b>:                        Matches any smarteditComponentType provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>\r\n     *  <li><b>Function</b>:                    Matches only the smarteditComponentType for which the provided callback returns true. This option allows more\r\n     *                                          control over the types to match.\r\n     *\r\n     * This function will be called with three parameters:\r\n     * <ul>\r\n     *  <li><b>componentTypeName:</b>         The smarteditComponentType name of the field. </li>\r\n     *  <li><b>field:</b>                     The field to evaluate. </li>\r\n     *  <li><b>componentTypeStructure:</b>    The smarteditComponentType structure of the CMS component that contains the field to evaluate.</li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * @param discriminator The matcher used to identify the discriminator for which for which to find its tab.\r\n     * There are three possible values for this parameter:\r\n     *  <li><b>String</b>:                      Matches only the discriminators whose name equals this string. </li>\r\n     *  <li><b>Null</b>:                        Matches any discriminator provided. It can be thought of as a wildcard. You can also use an asterisk (*).</li>\r\n     *  <li><b>Function</b>:                    Matches only the discriminators for which the provided callback returns true. This option allows more\r\n     *                                          control over the types to match.\r\n     *\r\n     * This function will be called with three parameters:\r\n     * <ul>\r\n     *  <li><b>discriminator</b>:               The discriminator of the field to evaluate. </li>\r\n     *  <li><b>field:</b>                       The field to evaluate. </li>\r\n     *  <li><b>componentTypeStructure:</b>      The smarteditComponentType of the component that contains the field to evaluate.</li>\r\n     * </ul>\r\n     * </li>\r\n     * </ul>\r\n     * @param tabId The ID of the tab where the field must be rendered in the generic editor.\r\n     */\r\n    addFieldTabMapping(structureTypeName: string | ((...args: any[]) => boolean), componentTypeName: string | ((...args: any[]) => boolean), discriminator: string | ((...args: any[]) => boolean), tabId: string): void;\r\n    /**\r\n     * This method is used by the genericEditor to retrieve the tab where the field will be rendered in the generic editor.\r\n     * If more than one tab matches the field provided, then the tab with the most accurate match will be used.\r\n     *\r\n     * @param field The object that represents the field that the tab is retrieved for.\r\n     * @param field.cmsStructureType The cmsStructureType that the tab is retrieved for.\r\n     * @param field.smarteditComponentType The smarteditComponentType that the tab is retrieved for.\r\n     * @param field.qualifier The field name of the smarteditComponentType that the tab is retrieved for.\r\n     * @param componentTypeStructure The smarteditComponentType structure of the component that contains the field that the tab is retrieved for.\r\n     * @returns The ID of the tab where this field must reside. Can be null if no adequate match is found.\r\n     *\r\n     */\r\n    getFieldTabMapping(field: GenericEditorField, componentTypeStructure: GenericEditorStructure): string;\r\n    _addMapping(structureTypeMatcher: string | ((...args: any[]) => boolean), componentTypeMatcher: string | ((...args: any[]) => boolean), discriminatorMatcher: string | ((...args: any[]) => boolean), mappedValue: any, collection: GenericEditorMapping[]): void;\r\n    _validateField(field: string | ((...args: any[]) => boolean)): string | ((...args: any[]) => boolean);\r\n    _getMapping(field: GenericEditorField, componentTypeStructure: GenericEditorStructure, collection: GenericEditorMapping[]): any;\r\n    _evaluateMapping(mappingEntry: GenericEditorMapping, field: GenericEditorField, componentTypeStructure: GenericEditorStructure): number;\r\n    _evaluateMatcher(matcher: string | ((...args: any[]) => boolean), actualValue: string, field: GenericEditorField, componentTypeStructure: GenericEditorStructure): number;\r\n    _registerDefaultFieldMappings(): void;\r\n    _cleanTemplate(template: string): string;\r\n    _exactValueMatchPredicate(expectedValue: string, actualValue: string): boolean;\r\n}\r\n"}}
