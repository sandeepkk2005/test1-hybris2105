{"version":3,"file":"LookupByPath.js","sourceRoot":"","sources":["../../src/logic/LookupByPath.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/**\r\n * A node in the path tree used in LookupByPath\r\n */\r\ninterface IPathTreeNode<TItem> {\r\n  /**\r\n   * The value that exactly matches the current relative path\r\n   */\r\n  value: TItem | undefined;\r\n  /**\r\n   * Child nodes by subfolder\r\n   */\r\n  children: Map<string, IPathTreeNode<TItem>> | undefined;\r\n}\r\n\r\n/**\r\n * This class is used to associate POSIX relative paths, such as those returned by `git` commands,\r\n * with entities that correspond with ancestor folders, such as Rush Projects.\r\n *\r\n * It is optimized for efficiently locating the nearest ancestor path with an associated value.\r\n *\r\n * @example\r\n * ```ts\r\n * const tree = new LookupByPath([['foo', 1], ['bar', 2], ['foo/bar', 3]]);\r\n * tree.getNearestAncestor('foo'); // returns 1\r\n * tree.getNearestAncestor('foo/baz'); // returns 1\r\n * tree.getNearestAncestor('baz'); // returns undefined\r\n * tree.getNearestAncestor('foo/bar/baz'); returns 3\r\n * tree.getNearestAncestor('bar/foo/bar'); returns 2\r\n * ```\r\n */\r\nexport class LookupByPath<TItem> {\r\n  /**\r\n   * The delimiter used to split paths\r\n   */\r\n  public readonly delimiter: string;\r\n  /**\r\n   * The root node of the tree, corresponding to the path ''\r\n   */\r\n  private readonly _root: IPathTreeNode<TItem>;\r\n\r\n  /**\r\n   * Constructs a new `LookupByPath`\r\n   *\r\n   * @param entries - Initial path-value pairs to populate the tree.\r\n   */\r\n  public constructor(entries?: Iterable<[string, TItem]>, delimiter?: string) {\r\n    this._root = {\r\n      value: undefined,\r\n      children: undefined\r\n    };\r\n\r\n    this.delimiter = delimiter ?? '/';\r\n\r\n    if (entries) {\r\n      for (const [path, item] of entries) {\r\n        this.setItem(path, item);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Iterates over the segments of a serialized path.\r\n   *\r\n   * @example\r\n   *\r\n   * `LookupByPath.iteratePathSegments('foo/bar/baz')` yields 'foo', 'bar', 'baz'\r\n   *\r\n   * `LookupByPath.iteratePathSegments('foo\\\\bar\\\\baz', '\\\\')` yields 'foo', 'bar', 'baz'\r\n   */\r\n  public static *iteratePathSegments(serializedPath: string, delimiter: string = '/'): Iterable<string> {\r\n    if (!serializedPath) {\r\n      return;\r\n    }\r\n\r\n    let nextIndex: number = serializedPath.indexOf(delimiter);\r\n    let previousIndex: number = 0;\r\n    while (nextIndex >= 0) {\r\n      yield serializedPath.slice(previousIndex, nextIndex);\r\n\r\n      previousIndex = nextIndex + 1;\r\n      nextIndex = serializedPath.indexOf(delimiter, previousIndex);\r\n    }\r\n\r\n    if (previousIndex + 1 < serializedPath.length) {\r\n      yield serializedPath.slice(previousIndex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Associates the value with the specified serialized path.\r\n   * If a value is already associated, will overwrite.\r\n   *\r\n   * @returns this, for chained calls\r\n   */\r\n  public setItem(serializedPath: string, value: TItem): this {\r\n    return this.setItemFromSegments(LookupByPath.iteratePathSegments(serializedPath, this.delimiter), value);\r\n  }\r\n\r\n  /**\r\n   * Associates the value with the specified path.\r\n   * If a value is already associated, will overwrite.\r\n   *\r\n   * @returns this, for chained calls\r\n   */\r\n  public setItemFromSegments(pathSegments: Iterable<string>, value: TItem): this {\r\n    let node: IPathTreeNode<TItem> = this._root;\r\n    for (const segment of pathSegments) {\r\n      if (!node.children) {\r\n        node.children = new Map();\r\n      }\r\n      let child: IPathTreeNode<TItem> | undefined = node.children.get(segment);\r\n      if (!child) {\r\n        node.children.set(\r\n          segment,\r\n          (child = {\r\n            value: undefined,\r\n            children: undefined\r\n          })\r\n        );\r\n      }\r\n      node = child;\r\n    }\r\n    node.value = value;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Searches for the item associated with `childPath`, or the nearest ancestor of that path that\r\n   * has an associated item.\r\n   *\r\n   * @returns the found item, or `undefined` if no item was found\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * const tree = new LookupByPath([['foo', 1], ['foo/bar', 2]]);\r\n   * tree.findChildPath('foo/baz'); // returns 1\r\n   * tree.findChildPath('foo/bar/baz'); // returns 2\r\n   * ```\r\n   */\r\n  public findChildPath(childPath: string): TItem | undefined {\r\n    return this.findChildPathFromSegments(LookupByPath.iteratePathSegments(childPath, this.delimiter));\r\n  }\r\n\r\n  /**\r\n   * Searches for the item associated with `childPathSegments`, or the nearest ancestor of that path that\r\n   * has an associated item.\r\n   *\r\n   * @returns the found item, or `undefined` if no item was found\r\n   *\r\n   * @example\r\n   * ```ts\r\n   * const tree = new LookupByPath([['foo', 1], ['foo/bar', 2]]);\r\n   * tree.findChildPathFromSegments(['foo', 'baz']); // returns 1\r\n   * tree.findChildPathFromSegments(['foo','bar', 'baz']); // returns 2\r\n   * ```\r\n   */\r\n  public findChildPathFromSegments(childPathSegments: Iterable<string>): TItem | undefined {\r\n    let node: IPathTreeNode<TItem> = this._root;\r\n    let best: TItem | undefined = node.value;\r\n    // Trivial cases\r\n    if (node.children) {\r\n      for (const segment of childPathSegments) {\r\n        const child: IPathTreeNode<TItem> | undefined = node.children.get(segment);\r\n        if (!child) {\r\n          break;\r\n        }\r\n        node = child;\r\n        best = node.value ?? best;\r\n        if (!node.children) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return best;\r\n  }\r\n}\r\n"]}