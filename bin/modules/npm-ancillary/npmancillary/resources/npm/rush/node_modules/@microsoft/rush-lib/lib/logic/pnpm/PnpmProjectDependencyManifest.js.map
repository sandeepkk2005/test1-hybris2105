{"version":3,"file":"PnpmProjectDependencyManifest.js","sourceRoot":"","sources":["../../../src/logic/pnpm/PnpmProjectDependencyManifest.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport crypto from 'crypto';\r\nimport { JsonFile, InternalError, FileSystem } from '@rushstack/node-core-library';\r\n\r\nimport { PnpmShrinkwrapFile, IPnpmShrinkwrapDependencyYaml } from './PnpmShrinkwrapFile';\r\nimport { RushConfigurationProject } from '../../api/RushConfigurationProject';\r\nimport { RushConstants } from '../RushConstants';\r\nimport { DependencySpecifier } from '../DependencySpecifier';\r\n\r\nexport interface IPnpmProjectDependencyManifestOptions {\r\n  pnpmShrinkwrapFile: PnpmShrinkwrapFile;\r\n  project: RushConfigurationProject;\r\n}\r\n\r\n/**\r\n * This class handles creating the project/.rush/temp/shrinkwrap-deps.json file\r\n * which tracks the direct and indirect dependencies that a project consumes. This is used\r\n * to better determine which projects should be rebuilt when dependencies are updated.\r\n */\r\nexport class PnpmProjectDependencyManifest {\r\n  /**\r\n   * This mapping is used to map all project dependencies and all their dependencies\r\n   * to their respective dependency integrity hash. For example, if the project contains\r\n   * a dependency A which itself has a dependency on B, the mapping would look like:\r\n   * 'A@1.2.3': '{Integrity of A}',\r\n   * 'B@4.5.6': '{Integrity of B}',\r\n   * ...\r\n   */\r\n  private _projectDependencyManifestFile: Map<string, string>;\r\n\r\n  private readonly _projectDependencyManifestFilename: string;\r\n  private readonly _pnpmShrinkwrapFile: PnpmShrinkwrapFile;\r\n  private readonly _project: RushConfigurationProject;\r\n\r\n  public constructor(options: IPnpmProjectDependencyManifestOptions) {\r\n    this._pnpmShrinkwrapFile = options.pnpmShrinkwrapFile;\r\n    this._project = options.project;\r\n    this._projectDependencyManifestFilename = PnpmProjectDependencyManifest.getFilePathForProject(\r\n      this._project\r\n    );\r\n\r\n    this._projectDependencyManifestFile = new Map<string, string>();\r\n  }\r\n\r\n  /**\r\n   * Get the fully-qualified path to the project/.rush/temp/shrinkwrap-deps.json\r\n   * for the specified project.\r\n   */\r\n  public static getFilePathForProject(project: RushConfigurationProject): string {\r\n    return path.join(project.projectRushTempFolder, RushConstants.projectDependencyManifestFilename);\r\n  }\r\n\r\n  public addDependency(\r\n    name: string,\r\n    version: string,\r\n    parentShrinkwrapEntry: Pick<\r\n      IPnpmShrinkwrapDependencyYaml,\r\n      'dependencies' | 'optionalDependencies' | 'peerDependencies'\r\n    >\r\n  ): void {\r\n    this._addDependencyInternal(name, version, parentShrinkwrapEntry);\r\n  }\r\n\r\n  /**\r\n   * Save the current state of the object to project/.rush/temp/shrinkwrap-deps.json\r\n   */\r\n  public async saveAsync(): Promise<void> {\r\n    const file: { [specifier: string]: string } = {};\r\n    const keys: string[] = Array.from(this._projectDependencyManifestFile.keys()).sort();\r\n    for (const key of keys) {\r\n      file[key] = this._projectDependencyManifestFile.get(key)!;\r\n    }\r\n    await JsonFile.saveAsync(file, this._projectDependencyManifestFilename, { ensureFolderExists: true });\r\n  }\r\n\r\n  /**\r\n   * If the project/.rush/temp/shrinkwrap-deps.json file exists, delete it. Otherwise, do nothing.\r\n   */\r\n  public deleteIfExistsAsync(): Promise<void> {\r\n    return FileSystem.deleteFileAsync(this._projectDependencyManifestFilename, { throwIfNotExists: false });\r\n  }\r\n\r\n  private _addDependencyInternal(\r\n    name: string,\r\n    version: string,\r\n    parentShrinkwrapEntry: Pick<\r\n      IPnpmShrinkwrapDependencyYaml,\r\n      'dependencies' | 'optionalDependencies' | 'peerDependencies'\r\n    >,\r\n    throwIfShrinkwrapEntryMissing: boolean = true\r\n  ): void {\r\n    const shrinkwrapEntry:\r\n      | IPnpmShrinkwrapDependencyYaml\r\n      | undefined = this._pnpmShrinkwrapFile.getShrinkwrapEntry(name, version);\r\n\r\n    if (!shrinkwrapEntry) {\r\n      if (throwIfShrinkwrapEntryMissing) {\r\n        throw new InternalError(`Unable to find dependency ${name} with version ${version} in shrinkwrap.`);\r\n      }\r\n      return;\r\n    }\r\n\r\n    const specifier: string = `${name}@${version}`;\r\n    let integrity: string = shrinkwrapEntry.resolution.integrity;\r\n\r\n    if (!integrity) {\r\n      // git dependency specifiers do not have an integrity entry\r\n\r\n      // Example ('integrity' doesn't exist in 'resolution'):\r\n      //\r\n      // github.com/chfritz/node-xmlrpc/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38:\r\n      //   dependencies:\r\n      //     sax: 1.2.4\r\n      //     xmlbuilder: 8.2.2\r\n      //   dev: false\r\n      //   engines:\r\n      //     node: '>=0.8'\r\n      //     npm: '>=1.0.0'\r\n      //   name: xmlrpc\r\n      //   resolution:\r\n      //     tarball: 'https://codeload.github.com/chfritz/node-xmlrpc/tar.gz/948db2fbd0260e5d56ed5ba58df0f5b6599bbe38'\r\n      //   version: 1.3.2\r\n\r\n      const sha256Digest: string = crypto\r\n        .createHash('sha256')\r\n        .update(JSON.stringify(shrinkwrapEntry))\r\n        .digest('hex');\r\n      integrity = `${name}@${version}:${sha256Digest}:`;\r\n    }\r\n\r\n    if (this._projectDependencyManifestFile.has(specifier)) {\r\n      if (this._projectDependencyManifestFile.get(specifier) !== integrity) {\r\n        throw new Error(`Collision: ${specifier} already exists in with a different integrity`);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Add the current dependency\r\n    this._projectDependencyManifestFile.set(specifier, integrity);\r\n\r\n    // Add the dependencies of the dependency\r\n    for (const dependencyName in shrinkwrapEntry.dependencies) {\r\n      if (shrinkwrapEntry.dependencies.hasOwnProperty(dependencyName)) {\r\n        const dependencyVersion: string = shrinkwrapEntry.dependencies[dependencyName];\r\n        this._addDependencyInternal(dependencyName, dependencyVersion, shrinkwrapEntry);\r\n      }\r\n    }\r\n\r\n    // Add the optional dependencies of the dependency\r\n    for (const optionalDependencyName in shrinkwrapEntry.optionalDependencies) {\r\n      if (shrinkwrapEntry.optionalDependencies.hasOwnProperty(optionalDependencyName)) {\r\n        // Optional dependencies may not exist. Don't blow up if it can't be found\r\n        const dependencyVersion: string = shrinkwrapEntry.optionalDependencies[optionalDependencyName];\r\n        this._addDependencyInternal(\r\n          optionalDependencyName,\r\n          dependencyVersion,\r\n          shrinkwrapEntry,\r\n          (throwIfShrinkwrapEntryMissing = false)\r\n        );\r\n      }\r\n    }\r\n\r\n    // When using workspaces, hoisting of peer dependencies to a singular top-level project is not possible.\r\n    // Therefore, all packages that are consumed should be specified in the dependency tree. Given this, there\r\n    // is no need to look for peer dependencies, since it is simply a constraint to be validated by the\r\n    // package manager. Also return if we have no peer dependencies to scavenge through.\r\n    if (\r\n      (this._project.rushConfiguration.pnpmOptions &&\r\n        this._project.rushConfiguration.pnpmOptions.useWorkspaces) ||\r\n      !shrinkwrapEntry.peerDependencies\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    for (const peerDependencyName of Object.keys(shrinkwrapEntry.peerDependencies)) {\r\n      // Check to see if the peer dependency is satisfied with the current shrinkwrap\r\n      // entry. If not, check the parent shrinkwrap entry. Finally, if neither have\r\n      // the specified dependency, check that the parent mentions the dependency in\r\n      // it's own peer dependencies. If it is, we can rely on the package manager and\r\n      // make the assumption that we've already found it further up the stack.\r\n      if (\r\n        (shrinkwrapEntry.dependencies && shrinkwrapEntry.dependencies.hasOwnProperty(peerDependencyName)) ||\r\n        (parentShrinkwrapEntry.dependencies &&\r\n          parentShrinkwrapEntry.dependencies.hasOwnProperty(peerDependencyName)) ||\r\n        (parentShrinkwrapEntry.peerDependencies &&\r\n          parentShrinkwrapEntry.peerDependencies.hasOwnProperty(peerDependencyName))\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      // As a last attempt, check if it's been hoisted up as a top-level dependency. If\r\n      // we can't find it, we can assume that it's already been provided somewhere up the\r\n      // dependency tree.\r\n      const topLevelDependencySpecifier:\r\n        | DependencySpecifier\r\n        | undefined = this._pnpmShrinkwrapFile.getTopLevelDependencyVersion(peerDependencyName);\r\n\r\n      if (topLevelDependencySpecifier) {\r\n        this._addDependencyInternal(\r\n          peerDependencyName,\r\n          this._pnpmShrinkwrapFile.getTopLevelDependencyKey(peerDependencyName)!,\r\n          shrinkwrapEntry\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n"]}