{"version":3,"file":"TaskSelector.js","sourceRoot":"","sources":["../../src/logic/TaskSelector.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { BuildCacheConfiguration } from '../api/BuildCacheConfiguration';\r\nimport { RushConfiguration } from '../api/RushConfiguration';\r\nimport { RushConfigurationProject } from '../api/RushConfigurationProject';\r\nimport { ProjectBuilder, convertSlashesForWindows } from '../logic/taskRunner/ProjectBuilder';\r\nimport { PackageChangeAnalyzer } from './PackageChangeAnalyzer';\r\nimport { TaskCollection } from './taskRunner/TaskCollection';\r\n\r\nexport interface ITaskSelectorConstructor {\r\n  rushConfiguration: RushConfiguration;\r\n  buildCacheConfiguration: BuildCacheConfiguration | undefined;\r\n  selection: ReadonlySet<RushConfigurationProject>;\r\n  commandName: string;\r\n  commandToRun: string;\r\n  customParameterValues: string[];\r\n  isQuietMode: boolean;\r\n  isIncrementalBuildAllowed: boolean;\r\n  ignoreMissingScript: boolean;\r\n  ignoreDependencyOrder: boolean;\r\n  packageDepsFilename: string;\r\n  packageChangeAnalyzer?: PackageChangeAnalyzer;\r\n}\r\n\r\n/**\r\n * This class is responsible for:\r\n *  - based on to/from flags, solving the dependency graph and figuring out which projects need to be run\r\n *  - creating a ProjectBuilder for each project that needs to be built\r\n *  - registering the necessary ProjectBuilders with the TaskRunner, which actually orchestrates execution\r\n */\r\nexport class TaskSelector {\r\n  private _options: ITaskSelectorConstructor;\r\n  private _packageChangeAnalyzer: PackageChangeAnalyzer;\r\n\r\n  public constructor(options: ITaskSelectorConstructor) {\r\n    this._options = options;\r\n\r\n    const { packageChangeAnalyzer = new PackageChangeAnalyzer(options.rushConfiguration) } = options;\r\n\r\n    this._packageChangeAnalyzer = packageChangeAnalyzer;\r\n  }\r\n\r\n  public static getScriptToRun(\r\n    rushProject: RushConfigurationProject,\r\n    commandToRun: string,\r\n    customParameterValues: string[]\r\n  ): string | undefined {\r\n    const script: string | undefined = TaskSelector._getScriptCommand(rushProject, commandToRun);\r\n\r\n    if (script === undefined) {\r\n      return undefined;\r\n    }\r\n\r\n    if (!script) {\r\n      return '';\r\n    } else {\r\n      const taskCommand: string = `${script} ${customParameterValues.join(' ')}`;\r\n      return process.platform === 'win32' ? convertSlashesForWindows(taskCommand) : taskCommand;\r\n    }\r\n  }\r\n\r\n  public registerTasks(): TaskCollection {\r\n    const selectedProjects: ReadonlySet<RushConfigurationProject> = this._computeSelectedProjects();\r\n\r\n    return this._createTaskCollection(selectedProjects);\r\n  }\r\n\r\n  private _computeSelectedProjects(): ReadonlySet<RushConfigurationProject> {\r\n    const { selection } = this._options;\r\n\r\n    if (selection.size) {\r\n      return selection;\r\n    }\r\n\r\n    // Default to all projects\r\n    return new Set(this._options.rushConfiguration.projects);\r\n  }\r\n\r\n  private _createTaskCollection(projects: ReadonlySet<RushConfigurationProject>): TaskCollection {\r\n    const taskCollection: TaskCollection = new TaskCollection();\r\n\r\n    // Register all tasks\r\n    for (const rushProject of projects) {\r\n      this._registerTask(rushProject, taskCollection);\r\n    }\r\n\r\n    if (!this._options.ignoreDependencyOrder) {\r\n      const dependencyMap: Map<RushConfigurationProject, Set<string>> = new Map();\r\n\r\n      // Generate the filtered dependency graph for selected projects\r\n      function getDependencyTaskNames(project: RushConfigurationProject): Set<string> {\r\n        const cached: Set<string> | undefined = dependencyMap.get(project);\r\n        if (cached) {\r\n          return cached;\r\n        }\r\n\r\n        const dependencyTaskNames: Set<string> = new Set();\r\n        dependencyMap.set(project, dependencyTaskNames);\r\n\r\n        for (const dep of project.dependencyProjects) {\r\n          if (projects.has(dep)) {\r\n            // Add direct relationships for projects in the set\r\n            dependencyTaskNames.add(ProjectBuilder.getTaskName(dep));\r\n          } else {\r\n            // Add indirect relationships for projects not in the set\r\n            for (const indirectDep of getDependencyTaskNames(dep)) {\r\n              dependencyTaskNames.add(indirectDep);\r\n            }\r\n          }\r\n        }\r\n\r\n        return dependencyTaskNames;\r\n      }\r\n\r\n      // Add ordering relationships for each dependency\r\n      for (const project of projects) {\r\n        taskCollection.addDependencies(ProjectBuilder.getTaskName(project), getDependencyTaskNames(project));\r\n      }\r\n    }\r\n\r\n    return taskCollection;\r\n  }\r\n\r\n  private _registerTask(project: RushConfigurationProject | undefined, taskCollection: TaskCollection): void {\r\n    if (!project || taskCollection.hasTask(ProjectBuilder.getTaskName(project))) {\r\n      return;\r\n    }\r\n\r\n    const commandToRun: string | undefined = TaskSelector.getScriptToRun(\r\n      project,\r\n      this._options.commandToRun,\r\n      this._options.customParameterValues\r\n    );\r\n    if (commandToRun === undefined && !this._options.ignoreMissingScript) {\r\n      throw new Error(\r\n        `The project [${project.packageName}] does not define a '${this._options.commandToRun}' command in the 'scripts' section of its package.json`\r\n      );\r\n    }\r\n\r\n    taskCollection.addTask(\r\n      new ProjectBuilder({\r\n        rushProject: project,\r\n        rushConfiguration: this._options.rushConfiguration,\r\n        buildCacheConfiguration: this._options.buildCacheConfiguration,\r\n        commandToRun: commandToRun || '',\r\n        commandName: this._options.commandName,\r\n        isIncrementalBuildAllowed: this._options.isIncrementalBuildAllowed,\r\n        packageChangeAnalyzer: this._packageChangeAnalyzer,\r\n        packageDepsFilename: this._options.packageDepsFilename\r\n      })\r\n    );\r\n  }\r\n\r\n  private static _getScriptCommand(\r\n    rushProject: RushConfigurationProject,\r\n    script: string\r\n  ): string | undefined {\r\n    if (!rushProject.packageJson.scripts) {\r\n      return undefined;\r\n    }\r\n\r\n    const rawCommand: string = rushProject.packageJson.scripts[script];\r\n\r\n    if (rawCommand === undefined || rawCommand === null) {\r\n      return undefined;\r\n    }\r\n\r\n    return rawCommand;\r\n  }\r\n}\r\n"]}