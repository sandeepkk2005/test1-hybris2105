{"code":"import { __decorate, __metadata, __param } from \"tslib\";\r\n/*\r\n * Copyright (c) 2021 SAP SE or an SAP affiliate company. All rights reserved.\r\n */\r\n/**\r\n * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.\r\n * @module smartutils\r\n */\r\nimport { HttpClient } from '@angular/common/http';\r\nimport { Inject, Injectable } from '@angular/core';\r\nimport { TranslateService } from '@ngx-translate/core';\r\nimport { LIBRARY_NAME } from '../../../constants';\r\nimport { IAlertService } from '../../../interfaces';\r\nimport { BooleanUtils } from '../../../utils';\r\nimport { clientErrorPredicate, noInternetConnectionErrorPredicate, readPredicate, retriableErrorPredicate, serverErrorPredicate, timeoutErrorPredicate, DefaultRetryStrategy, ExponentialRetryStrategy, LinearRetryStrategy, OperationContextService } from './retries';\r\nexport var OPERATION_CONTEXT_TOKEN = LIBRARY_NAME + \"_OPERATION_CONTEXT\";\r\n/**\r\n * @ngdoc service\r\n * @name @smartutils.services:retryInterceptor\r\n *\r\n * @description\r\n * The retryInterceptor provides the functionality to register a set of predicates with their associated retry strategies.\r\n * Each time an HTTP request fails, the service try to find a matching retry strategy for the given response.\r\n */\r\nvar RetryInterceptor = /** @class */ (function () {\r\n    function RetryInterceptor(httpClient, translate, operationContextService, alertService, booleanUtils, defaultRetryStrategy, exponentialRetryStrategy, linearRetryStrategy, OPERATION_CONTEXT) {\r\n        this.httpClient = httpClient;\r\n        this.translate = translate;\r\n        this.operationContextService = operationContextService;\r\n        this.alertService = alertService;\r\n        this.OPERATION_CONTEXT = OPERATION_CONTEXT;\r\n        this.TRANSLATE_NAMESPACE = 'se.gracefuldegradation.';\r\n        this.predicatesRegistry = [];\r\n        this.requestToRetryTegistry = {};\r\n        this.register(noInternetConnectionErrorPredicate, exponentialRetryStrategy)\r\n            .register(booleanUtils.isAnyTruthy(clientErrorPredicate, timeoutErrorPredicate), defaultRetryStrategy)\r\n            .register(booleanUtils.areAllTruthy(readPredicate, retriableErrorPredicate), defaultRetryStrategy)\r\n            .register(serverErrorPredicate, exponentialRetryStrategy);\r\n    }\r\n    RetryInterceptor.prototype.predicate = function (request, response) {\r\n        return this.findMatchingStrategy(request, response) !== null;\r\n    };\r\n    RetryInterceptor.prototype.responseError = function (request, response) {\r\n        var retryStrategy = this.retrieveRetryStrategy(request);\r\n        if (!retryStrategy) {\r\n            var StrategyHolder = this.findMatchingStrategy(request, response);\r\n            if (StrategyHolder) {\r\n                this.alertService.showWarning({\r\n                    message: this.translate.instant(this.TRANSLATE_NAMESPACE + 'stillworking')\r\n                });\r\n                retryStrategy = new StrategyHolder();\r\n                retryStrategy.attemptCount = 0;\r\n                this.storeRetryStrategy(request, retryStrategy);\r\n            }\r\n            else {\r\n                return Promise.reject(response);\r\n            }\r\n        }\r\n        return this.handleRetry(retryStrategy, request, response);\r\n    };\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:retryInterceptor#register\r\n     * @methodOf @smartutils.services:retryInterceptor\r\n     *\r\n     * @description\r\n     * Register a new predicate with it's associated strategyHolder.\r\n     *\r\n     * @param {Function} predicate This function takes the 'response' {Object} argument and an (optional) operationContext {String}. This function must return a Boolean that is true if the given response match the predicate.\r\n     * @param {Function} retryStrategy This function will be instanciated at run-time. See {@link @smartutils.services:IRetryStrategy IRetryStrategy}.\r\n     *\r\n     * @return {Object} retryInterceptor The retryInterceptor service.\r\n     *\r\n     * @example\r\n     * ```js\r\n     *      var customPredicate = function(request, response, operationContext) {\r\n     *          return response.status === 500 && operationContext === OPERATION_CONTEXT.TOOLING;\r\n     *      };\r\n     *      var StrategyHolder = function() {\r\n     *          // set the firstFastRetry value to true for the retry made immediately only for the very first retry (subsequent retries will remain subject to the calculateNextDelay response)\r\n     *          this.firstFastRetry = true;\r\n     *      };\r\n     *      StrategyHolder.prototype.canRetry = function() {\r\n     *          // this function must return a {Boolean} if the given request must be retried.\r\n     *          // use this.attemptCount value to determine if the function should return true or false\r\n     *      };\r\n     *      StrategyHolder.prototype.calculateNextDelay = function() {\r\n     *          // this function must return the next delay time {Number}\r\n     *          // use this.attemptCount value to determine the next delay value\r\n     *      };\r\n     *      retryInterceptor.register(customPredicate, StrategyHolder);\r\n     * ```\r\n     */\r\n    RetryInterceptor.prototype.register = function (predicate, retryStrategy) {\r\n        if (typeof predicate !== 'function') {\r\n            throw new Error('retryInterceptor.register error: predicate must be a function');\r\n        }\r\n        if (typeof retryStrategy !== 'function') {\r\n            throw new Error('retryInterceptor.register error: retryStrategy must be a function');\r\n        }\r\n        this.predicatesRegistry.unshift({\r\n            predicate: predicate,\r\n            retryStrategy: retryStrategy\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Find a matching strategy for the given response and (optional) operationContext\r\n     * If not provided, the default operationContext is OPERATION_CONTEXT.INTERACTIVE\r\n     *\r\n     * @param {Object} response The http response object\r\n     *\r\n     * @return {Function} The matching retryStrategy\r\n     */\r\n    RetryInterceptor.prototype.findMatchingStrategy = function (request, response) {\r\n        var operationContext = this.operationContextService.findOperationContext(request.url) ||\r\n            this.OPERATION_CONTEXT.INTERACTIVE;\r\n        var matchStrategy = this.predicatesRegistry.find(function (predicateObj) {\r\n            return predicateObj.predicate(request, response, operationContext);\r\n        });\r\n        return matchStrategy ? matchStrategy.retryStrategy : null;\r\n    };\r\n    RetryInterceptor.prototype.handleRetry = function (retryStrategy, request, response) {\r\n        var _this = this;\r\n        retryStrategy.attemptCount++;\r\n        if (retryStrategy.canRetry()) {\r\n            var delay_1 = retryStrategy.firstFastRetry ? 0 : retryStrategy.calculateNextDelay();\r\n            retryStrategy.firstFastRetry = false;\r\n            return new Promise(function (resolve, reject) {\r\n                setTimeout(function () {\r\n                    _this.httpClient\r\n                        .request(request)\r\n                        .toPromise()\r\n                        .then(function (result) {\r\n                        _this.removeRetryStrategy(request);\r\n                        return resolve(result);\r\n                    }, function (error) { return reject(error); });\r\n                }, delay_1);\r\n            });\r\n        }\r\n        else {\r\n            this.alertService.showDanger({\r\n                message: this.translate.instant(this.TRANSLATE_NAMESPACE + 'somethingwrong')\r\n            });\r\n            return Promise.reject(response);\r\n        }\r\n    };\r\n    RetryInterceptor.prototype.storeRetryStrategy = function (request, retryStrategy) {\r\n        this.requestToRetryTegistry[this.getRequestUUID(request)] = retryStrategy;\r\n    };\r\n    RetryInterceptor.prototype.removeRetryStrategy = function (request) {\r\n        delete this.requestToRetryTegistry[this.getRequestUUID(request)];\r\n    };\r\n    RetryInterceptor.prototype.retrieveRetryStrategy = function (request) {\r\n        return this.requestToRetryTegistry[this.getRequestUUID(request)];\r\n    };\r\n    RetryInterceptor.prototype.getRequestUUID = function (request) {\r\n        return request.clone().toString();\r\n    };\r\n    RetryInterceptor = __decorate([\r\n        Injectable(),\r\n        __param(5, Inject(DefaultRetryStrategy)),\r\n        __param(6, Inject(ExponentialRetryStrategy)),\r\n        __param(7, Inject(LinearRetryStrategy)),\r\n        __param(8, Inject(OPERATION_CONTEXT_TOKEN)),\r\n        __metadata(\"design:paramtypes\", [HttpClient,\r\n            TranslateService,\r\n            OperationContextService,\r\n            IAlertService,\r\n            BooleanUtils, Object, Object, Object, Object])\r\n    ], RetryInterceptor);\r\n    return RetryInterceptor;\r\n}());\r\nexport { RetryInterceptor };\r\n//# sourceMappingURL=retry.interceptor.js.map","references":["/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedittools/common/temp/node_modules/.pnpm/@angular/common@8.2.14_@angular+core@8.2.14+rxjs@6.5.4/node_modules/@angular/common/http.d.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedittools/common/temp/node_modules/.pnpm/@angular/core@8.2.14_rxjs@6.5.4+zone.js@0.9.1/node_modules/@angular/core/core.d.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedittools/common/temp/node_modules/.pnpm/@ngx-translate/core@11.0.1_@angular+core@8.2.14+rxjs@6.5.4/node_modules/@ngx-translate/core/ngx-translate-core.d.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/src/constants.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/src/dtos/index.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/src/interfaces/index.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/src/types/index.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/src/utils/index.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/src/services/interceptors/i-http-error.interceptor.ts","/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/src/services/interceptors/errors/retries/index.ts"],"map":"{\"version\":3,\"file\":\"retry.interceptor.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/services/interceptors/errors/retry.interceptor.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/sandeepkalpane/Data/hybris2105/hybris/bin/modules/smartedit/smartedit/apps/smart-utils/services/interceptors/errors/retry.interceptor.d.ts","writeByteOrderMark":false,"text":"/**\r\n * Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved.\r\n * @module smartutils\r\n */\r\nimport { HttpClient, HttpErrorResponse, HttpRequest } from '@angular/common/http';\r\nimport { TranslateService } from '@ngx-translate/core';\r\nimport { TypedMap } from '../../../dtos';\r\nimport { IAlertService } from '../../../interfaces';\r\nimport { Class } from '../../../types';\r\nimport { BooleanUtils } from '../../../utils';\r\nimport { IHttpErrorInterceptor } from '../i-http-error.interceptor';\r\nimport { IRetryStrategy, OperationContextService } from './retries';\r\nexport declare type RetryPredicate = (request: HttpRequest<any>, response: HttpErrorResponse, operationContext?: string) => boolean;\r\nexport declare const OPERATION_CONTEXT_TOKEN: string;\r\n/**\r\n * @ngdoc service\r\n * @name @smartutils.services:retryInterceptor\r\n *\r\n * @description\r\n * The retryInterceptor provides the functionality to register a set of predicates with their associated retry strategies.\r\n * Each time an HTTP request fails, the service try to find a matching retry strategy for the given response.\r\n */\r\nexport declare class RetryInterceptor<T = any> implements IHttpErrorInterceptor<T> {\r\n    private httpClient;\r\n    private translate;\r\n    private operationContextService;\r\n    private alertService;\r\n    private OPERATION_CONTEXT;\r\n    private TRANSLATE_NAMESPACE;\r\n    private predicatesRegistry;\r\n    private requestToRetryTegistry;\r\n    constructor(httpClient: HttpClient, translate: TranslateService, operationContextService: OperationContextService, alertService: IAlertService, booleanUtils: BooleanUtils, defaultRetryStrategy: Class<IRetryStrategy>, exponentialRetryStrategy: Class<IRetryStrategy>, linearRetryStrategy: Class<IRetryStrategy>, OPERATION_CONTEXT: TypedMap<string>);\r\n    predicate(request: HttpRequest<T>, response: HttpErrorResponse): boolean;\r\n    responseError(request: HttpRequest<T>, response: HttpErrorResponse): Promise<any>;\r\n    /**\r\n     * @ngdoc method\r\n     * @name @smartutils.services:retryInterceptor#register\r\n     * @methodOf @smartutils.services:retryInterceptor\r\n     *\r\n     * @description\r\n     * Register a new predicate with it's associated strategyHolder.\r\n     *\r\n     * @param {Function} predicate This function takes the 'response' {Object} argument and an (optional) operationContext {String}. This function must return a Boolean that is true if the given response match the predicate.\r\n     * @param {Function} retryStrategy This function will be instanciated at run-time. See {@link @smartutils.services:IRetryStrategy IRetryStrategy}.\r\n     *\r\n     * @return {Object} retryInterceptor The retryInterceptor service.\r\n     *\r\n     * @example\r\n     * ```js\r\n     *      var customPredicate = function(request, response, operationContext) {\r\n     *          return response.status === 500 && operationContext === OPERATION_CONTEXT.TOOLING;\r\n     *      };\r\n     *      var StrategyHolder = function() {\r\n     *          // set the firstFastRetry value to true for the retry made immediately only for the very first retry (subsequent retries will remain subject to the calculateNextDelay response)\r\n     *          this.firstFastRetry = true;\r\n     *      };\r\n     *      StrategyHolder.prototype.canRetry = function() {\r\n     *          // this function must return a {Boolean} if the given request must be retried.\r\n     *          // use this.attemptCount value to determine if the function should return true or false\r\n     *      };\r\n     *      StrategyHolder.prototype.calculateNextDelay = function() {\r\n     *          // this function must return the next delay time {Number}\r\n     *          // use this.attemptCount value to determine the next delay value\r\n     *      };\r\n     *      retryInterceptor.register(customPredicate, StrategyHolder);\r\n     * ```\r\n     */\r\n    register(predicate: RetryPredicate, retryStrategy: Class<IRetryStrategy>): RetryInterceptor<T>;\r\n    /**\r\n     * Find a matching strategy for the given response and (optional) operationContext\r\n     * If not provided, the default operationContext is OPERATION_CONTEXT.INTERACTIVE\r\n     *\r\n     * @param {Object} response The http response object\r\n     *\r\n     * @return {Function} The matching retryStrategy\r\n     */\r\n    private findMatchingStrategy;\r\n    private handleRetry;\r\n    private storeRetryStrategy;\r\n    private removeRetryStrategy;\r\n    private retrieveRetryStrategy;\r\n    private getRequestUUID;\r\n}\r\n"}}
