{"version":3,"file":"Selection.js","sourceRoot":"","sources":["../../src/logic/Selection.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAY3D;;GAEG;AACH,MAAa,SAAS;IACpB;;OAEG;IACI,MAAM,CAAC,YAAY,CAAI,KAAkB,EAAE,GAAG,IAAsB;QACzE,OAAO,IAAI,GAAG,CAAC,oBAAoB,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC;IACvD,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,KAAK,CAAI,GAAG,IAAmB;QAC3C,OAAO,IAAI,GAAG,CAAC,qBAAqB,CAAI,GAAG,IAAI,CAAC,CAAC,CAAC;IACpD,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,qBAAqB,CAA+B,KAAkB;QAClF,OAAO,SAAS,CAAC,KAAK,EAAE,sBAAsB,CAAC,CAAC;IAClD,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,kBAAkB,CAA+B,KAAkB;QAC/E,OAAO,SAAS,CAAC,KAAK,EAAE,eAAe,CAAC,CAAC;IAC3C,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,CAAC,oBAAoB,CAA+B,KAAkB;QAClF,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;YACxB,KAAK,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC;SAChC;IACH,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,CAAC,iBAAiB,CAA+B,KAAkB;QAC/E,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;YACxB,KAAK,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAC;SAC/B;IACH,CAAC;CACF;AA9CD,8BA8CC;AASD,QAAQ,CAAC,CAAC,oBAAoB,CAAI,KAAkB,EAAE,GAAG,IAAsB;IAC7E,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;QACxB,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,GAAmB,EAAE,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE;YACtD,MAAM,IAAI,CAAC;SACZ;KACF;AACH,CAAC;AAED,QAAQ,CAAC,CAAC,qBAAqB,CAAI,GAAG,IAAmB;IACvD,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;QACtB,KAAK,CAAC,CAAC,GAAG,CAAC;KACZ;AACH,CAAC;AAED;;GAEG;AACH,SAAS,sBAAsB,CAA+B,OAAU,EAAE,SAAiB;IACzF,KAAK,MAAM,GAAG,IAAI,OAAO,CAAC,kBAAkB,EAAE;QAC5C,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;KACpB;AACH,CAAC;AACD;;GAEG;AACH,SAAS,eAAe,CAA+B,OAAU,EAAE,SAAiB;IAClF,KAAK,MAAM,GAAG,IAAI,OAAO,CAAC,iBAAiB,EAAE;QAC3C,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;KACpB;AACH,CAAC;AAED;;;GAGG;AACH,SAAS,SAAS,CAAI,KAAkB,EAAE,UAAqC;IAC7E,MAAM,MAAM,GAAW,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC;IACtC,KAAK,MAAM,IAAI,IAAI,MAAM,EAAE;QACzB,UAAU,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;KAC1B;IACD,OAAO,MAAM,CAAC;AAChB,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/**\r\n * Minimal subset of RushConfigurationProject needed for graph manipulation.\r\n * Used to facilitate type safety in unit tests.\r\n * @internal\r\n */\r\nexport interface IPartialProject<T extends IPartialProject<T>> {\r\n  dependencyProjects: ReadonlySet<T>;\r\n  consumingProjects: ReadonlySet<T>;\r\n}\r\n\r\n/**\r\n * This namespace contains functions for manipulating sets of projects\r\n */\r\nexport class Selection {\r\n  /**\r\n   * Computes the intersection of two or more sets.\r\n   */\r\n  public static intersection<T>(first: Iterable<T>, ...rest: ReadonlySet<T>[]): Set<T> {\r\n    return new Set(generateIntersection(first, ...rest));\r\n  }\r\n\r\n  /**\r\n   * Computes the union of two or more sets.\r\n   */\r\n  public static union<T>(...sets: Iterable<T>[]): Set<T> {\r\n    return new Set(generateConcatenation<T>(...sets));\r\n  }\r\n\r\n  /**\r\n   * Computes a set that contains the input projects and all the direct and indirect dependencies thereof.\r\n   */\r\n  public static expandAllDependencies<T extends IPartialProject<T>>(input: Iterable<T>): Set<T> {\r\n    return expandAll(input, expandDependenciesStep);\r\n  }\r\n\r\n  /**\r\n   * Computes a set that contains the input projects and all projects that directly or indirectly depend on them.\r\n   */\r\n  public static expandAllConsumers<T extends IPartialProject<T>>(input: Iterable<T>): Set<T> {\r\n    return expandAll(input, expandConsumers);\r\n  }\r\n\r\n  /**\r\n   * Iterates the direct dependencies of the listed projects. May contain duplicates.\r\n   */\r\n  public static *directDependenciesOf<T extends IPartialProject<T>>(input: Iterable<T>): Iterable<T> {\r\n    for (const item of input) {\r\n      yield* item.dependencyProjects;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Iterates the projects that declare any of the listed projects as a dependency. May contain duplicates.\r\n   */\r\n  public static *directConsumersOf<T extends IPartialProject<T>>(input: Iterable<T>): Iterable<T> {\r\n    for (const item of input) {\r\n      yield* item.consumingProjects;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Function used for incremental mutation of a set, e.g. when expanding dependencies or dependents\r\n */\r\ninterface IExpansionStepFunction<T> {\r\n  (project: T, targetSet: Set<T>): void;\r\n}\r\n\r\nfunction* generateIntersection<T>(first: Iterable<T>, ...rest: ReadonlySet<T>[]): Iterable<T> {\r\n  for (const item of first) {\r\n    if (rest.every((set: ReadonlySet<T>) => set.has(item))) {\r\n      yield item;\r\n    }\r\n  }\r\n}\r\n\r\nfunction* generateConcatenation<T>(...sets: Iterable<T>[]): Iterable<T> {\r\n  for (const set of sets) {\r\n    yield* set;\r\n  }\r\n}\r\n\r\n/**\r\n * Adds all dependencies of the specified project to the target set.\r\n */\r\nfunction expandDependenciesStep<T extends IPartialProject<T>>(project: T, targetSet: Set<T>): void {\r\n  for (const dep of project.dependencyProjects) {\r\n    targetSet.add(dep);\r\n  }\r\n}\r\n/**\r\n * Adds all projects that declare the specified project as a dependency to the target set.\r\n */\r\nfunction expandConsumers<T extends IPartialProject<T>>(project: T, targetSet: Set<T>): void {\r\n  for (const dep of project.consumingProjects) {\r\n    targetSet.add(dep);\r\n  }\r\n}\r\n\r\n/**\r\n * Computes a set derived from the input by cloning it, then iterating over every member of the new set and\r\n * calling a step function that may add more elements to the set.\r\n */\r\nfunction expandAll<T>(input: Iterable<T>, expandStep: IExpansionStepFunction<T>): Set<T> {\r\n  const result: Set<T> = new Set(input);\r\n  for (const item of result) {\r\n    expandStep(item, result);\r\n  }\r\n  return result;\r\n}\r\n"]}